/*
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘           BookBuddy V1.0 - Production Firmware                  â•‘
 * â•‘                                                                  â•‘
 * â•‘  Hardware: ESP32 + ILI9488 3.5" (480x320) + DS3231 RTC          â•‘
 * â•‘           + DFPlayer Mini + 5 Book Switches + Touch + Buzzer     â•‘
 * â•‘                                                                  â•‘
 * â•‘  FIXES APPLIED:                                                  â•‘
 * â•‘  âœ“ Professional UI with clean text rendering                    â•‘
 * â•‘  âœ“ FIXED face expressions (no more evil smile)                  â•‘
 * â•‘  âœ“ Proper emotion curves with clamped values                    â•‘
 * â•‘  âœ“ New logic: books REMOVED = studying = happiness upgrade      â•‘
 * â•‘  âœ“ 5-stage degradation every 5 min if no activity               â•‘
 * â•‘  âœ“ NTP â†’ RTC time sync with battery backup                     â•‘
 * â•‘  âœ“ Full embedded dashboard with 4 tabs                          â•‘
 * â•‘  âœ“ WebSocket bidirectional commands                             â•‘
 * â•‘  âœ“ Persistent settings (NVS)                                    â•‘
 * â•‘  âœ“ Event history (50 entries)                                    â•‘
 * â•‘  âœ“ OTA firmware update                                           â•‘
 * â•‘  âœ“ mDNS (bookbuddy.local)                                       â•‘
 * â•‘  âœ“ Non-blocking debounce on all inputs                          â•‘
 * â•‘                                                                  â•‘
 * â•‘  WIRING:                                                         â•‘
 * â•‘  TFT: SPI (User_Setup.h)  â”‚  RTC: SDA=21, SCL=22              â•‘
 * â•‘  DFPlayer: RX=5, TX=18    â”‚  Touch: GPIO4                      â•‘
 * â•‘  Books: 12,14,25,32,33    â”‚  Buzzer: GPIO26                    â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

#include <Wire.h>
#include <RTClib.h>
#include <SPI.h>
#include <TFT_eSPI.h>
#include <DFRobotDFPlayerMini.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ESPmDNS.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <Update.h>
#include <time.h>  // For NTP

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const char* WIFI_SSID    = "20";
const char* WIFI_PASS    = "12345678";
const char* MDNS_NAME    = "bookbuddy";
const char* FW_VERSION   = "1.0.0";
const char* DEVICE_NAME  = "BookBuddy";

// NTP Configuration
const char* NTP_SERVER1  = "pool.ntp.org";
const char* NTP_SERVER2  = "time.google.com";
const long  GMT_OFFSET   = 19800;  // IST = UTC+5:30 = 19800 seconds
const int   DST_OFFSET   = 0;

// â”€â”€ Pin Definitions â”€â”€
#define PIN_ENGLISH    12
#define PIN_HINDI      14
#define PIN_MATHS      25
#define PIN_MARATHI    32
#define PIN_SCIENCE    33
#define PIN_TOUCH      4
#define PIN_DF_RX      5
#define PIN_DF_TX      18
#define PIN_BUZZER     26

// â”€â”€ Audio Track IDs â”€â”€
namespace Audio {
  enum Track : uint8_t {
    HEY             = 1,
    I_AM            = 2,
    BOOKBUDDY       = 3,
    YOUR_PARTNER    = 4,
    TIME_TO_STUDY   = 5,
    // Book placed: 11-15
    ENGLISH_PLACED  = 11,
    HINDI_PLACED    = 12,
    MATHS_PLACED    = 13,
    MARATHI_PLACED  = 14,
    SCIENCE_PLACED  = 15,
    // Book time: 21-25
    ENGLISH_TIME    = 21,
    HINDI_TIME      = 22,
    MATHS_TIME      = 23,
    MARATHI_TIME    = 24,
    SCIENCE_TIME    = 25,
    // General
    ALL_READY       = 30,
    GOOD_JOB        = 31,
    WELL_DONE       = 32,
    UH_OH           = 33,
    CHIME           = 34,
    CLICK           = 35,
    // New V1 audio
    MISS_YOU        = 36,
    GREAT_PROGRESS  = 37,
    DOING_AMAZING   = 38,
    DONT_FORGET     = 39,
    WELCOME_BACK    = 40,
    LEARN_NEW       = 41,
    SO_PROUD        = 42,
    TAKE_BREAK      = 43,
    ONE_MORE        = 44,
    ALL_COVERED     = 45,
    SAD_CHIME       = 46,
    HAPPY_CHIME     = 47,
    TIME_SYNCED     = 48,
    GOOD_MORNING    = 49,
    GOOD_EVENING    = 50,
  };
  
  // Helper arrays
  const uint8_t BOOK_PLACED[5] = {11, 12, 13, 14, 15};
  const uint8_t BOOK_TIME[5]   = {21, 22, 23, 24, 25};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TYPE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum class Emotion : uint8_t {
  CALM,           // Default, gentle smile
  CONTENT,        // Slightly happier
  HAPPY,          // Clearly happy
  VERY_HAPPY,     // Big smile
  PROUD,          // Maximum happiness
  NEUTRAL,        // Flat expression
  BORED,          // Slight downturn
  SAD,            // Clear sadness
  VERY_SAD,       // Deep sadness
  PLEADING        // "Please come study" face
};

enum class SysState : uint8_t {
  BOOTING,
  INTRO,
  BOOT_CALM,      // First 5 min - calm face
  ACTIVE,         // Normal operation
  DEGRADING,      // No activity, emotion dropping
  OVERLAY         // Showing text overlay
};

struct Book {
  const char* name;
  uint8_t     pin;
  // State
  bool     isOnRack;         // true = on rack, false = removed (being studied)
  bool     lastReading;      // for debounce
  uint32_t debounceMs;       // debounce timestamp
  bool     stableState;      // debounced state
  // Time tracking
  uint32_t removedEpoch;     // when book was removed from rack
  uint32_t totalStudySeconds; // cumulative study time
  uint32_t lastSessionSecs;  // last session duration
  bool     isBeingStudied;   // currently removed for study
};

struct Settings {
  uint8_t  volume;
  bool     soundOn;
  bool     animOn;
  uint32_t bootCalmMs;       // How long to stay calm after boot
  uint32_t degradeStepMs;    // Time between degrade stages
  uint8_t  degradeStages;    // Number of degrade stages
};

struct FaceState {
  int  eyeOpenness;   // 0=closed, 28=normal, 34=wide
  int  pupilY;        // Vertical pupil offset
  int  smileAmount;   // -100 to +100 (negative=frown, positive=smile)
  bool eyesClosed;    // For happy squint
  int  mouthOpen;     // 0=closed, 1-3=open levels
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GLOBALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TFT_eSPI             tft = TFT_eSPI();
RTC_DS3231           rtc;
HardwareSerial       dfSerial(1);
DFRobotDFPlayerMini  df;
AsyncWebServer       webServer(80);
AsyncWebSocket       ws("/ws");
Preferences          prefs;

// â”€â”€ Display â”€â”€
const int SCR_W = 480, SCR_H = 320;
const int CX = 240, CY = 160;

// Colors
#define C_BG      0x1E9F   // Blue background
#define C_BLACK   0x0000
#define C_WHITE   0xFFFF
#define C_DGRAY   tft.color565(60, 60, 80)
#define C_LGRAY   tft.color565(200, 200, 210)
#define C_PINK    tft.color565(255, 180, 190)
#define C_RED     tft.color565(255, 100, 100)
#define C_GREEN   tft.color565(80, 220, 120)
#define C_AMBER   tft.color565(255, 180, 50)
#define C_DBLUE   tft.color565(30, 60, 120)

// â”€â”€ Books â”€â”€
Book books[5] = {
  {"English", PIN_ENGLISH, true,true,0,true, 0,0,0,false},
  {"Hindi",   PIN_HINDI,   true,true,0,true, 0,0,0,false},
  {"Maths",   PIN_MATHS,   true,true,0,true, 0,0,0,false},
  {"Marathi", PIN_MARATHI, true,true,0,true, 0,0,0,false},
  {"Science", PIN_SCIENCE, true,true,0,true, 0,0,0,false}
};

// â”€â”€ Settings â”€â”€
Settings cfg = {
  .volume        = 22,
  .soundOn       = true,
  .animOn        = true,
  .bootCalmMs    = 300000,    // 5 min
  .degradeStepMs = 300000,    // 5 min per stage
  .degradeStages = 5
};

// â”€â”€ State â”€â”€
SysState   sysState       = SysState::BOOTING;
Emotion    emotion        = Emotion::CALM;
Emotion    prevEmotion    = Emotion::CALM;
uint32_t   stateStartMs   = 0;
uint32_t   lastActivityMs = 0;
uint8_t    degradeLevel   = 0;
bool       reminderDone   = false;

// Book counting
uint8_t booksBeingStudied = 0;  // Books REMOVED from rack
uint8_t prevStudyCount    = 0;
bool    allRemovedOnce    = false;

// â”€â”€ Touch â”€â”€
bool     touchDown     = false;
uint32_t touchDownMs   = 0;
const uint32_t LONG_PRESS_MS = 2000;

// â”€â”€ Face Animation â”€â”€
FaceState face    = {28, 0, 30, false, 0};  // Current
FaceState faceTarget = {28, 0, 30, false, 0};  // Target
uint32_t  lastAnimMs = 0;
uint32_t  lastBlinkMs = 0;
bool      showingOverlay = false;

// â”€â”€ Face Geometry (for 480x320) â”€â”€
const int F_EYE_SPACE   = 70;
const int F_EYE_Y       = -30;
const int F_EYE_R       = 34;
const int F_PUPIL_R     = 14;
const int F_CHEEK_R     = 20;
const int F_CHEEK_X     = 110;
const int F_CHEEK_Y     = 25;
const int F_MOUTH_Y     = 60;
const int F_MOUTH_W     = 55;

// â”€â”€ Hardware Status â”€â”€
bool hw_rtc     = false;
bool hw_df      = false;
bool hw_wifi    = false;
bool hw_ntp     = false;

// â”€â”€ WebSocket â”€â”€
uint32_t lastWsMs = 0;

// â”€â”€ History â”€â”€
struct HistEvent {
  uint32_t epoch;
  char event[20];
  char detail[32];
};
#define HIST_MAX 50
HistEvent hist[HIST_MAX];
int histHead = 0, histCount = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup() {
  Serial.begin(115200);
  delay(300);
  
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘      BookBuddy V1.0 Starting         â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  loadSettings();
  setupPins();
  setupDisplay();
  setupDFPlayer();
  setupRTC();
  setupWiFi();
  
  if (hw_wifi) {
    setupNTP();
    setupWebSocket();
    setupWebServer();
  }
  
  addHist("BOOT", FW_VERSION);
  
  // Play time-appropriate greeting
  if (hw_df && hw_rtc) {
    DateTime now = rtc.now();
    if (now.hour() < 12) playTrack(Audio::GOOD_MORNING);
    else playTrack(Audio::GOOD_EVENING);
  }
  
  // Intro
  sysState = SysState::INTRO;
  showIntro();
  
  // Enter boot calm
  changeState(SysState::BOOT_CALM);
  emotion = Emotion::CALM;
  faceTarget = emotionToFace(Emotion::CALM);
  face = faceTarget;
  
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
  lastActivityMs = millis();
  
  Serial.printf("\nâœ“ Ready! Free heap: %d\n", ESP.getFreeHeap());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loop() {
  if (hw_wifi) ws.cleanupClients();
  
  readBooks();
  readTouch();
  calcEmotion();
  
  if (emotion != prevEmotion) {
    Serial.printf("ğŸ˜€ Emotion: %s â†’ %s\n", 
                  emoStr(prevEmotion).c_str(), emoStr(emotion).c_str());
    faceTarget = emotionToFace(emotion);
    emotionAudio();
    prevEmotion = emotion;
  }
  
  if (!showingOverlay && cfg.animOn) {
    animateFace();
    blinkCheck();
  }
  
  broadcastWs();
  delay(25);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INITIALIZATION FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupPins() {
  pinMode(PIN_BUZZER, OUTPUT);
  digitalWrite(PIN_BUZZER, LOW);
  buzzPattern(1, 150, 0);
  
  for (int i = 0; i < 5; i++) {
    pinMode(books[i].pin, INPUT_PULLUP);
    // Read initial state
    books[i].isOnRack = digitalRead(books[i].pin);  // HIGH = on rack (pullup)
    books[i].lastReading = books[i].isOnRack;
    books[i].stableState = books[i].isOnRack;
  }
  
  pinMode(PIN_TOUCH, INPUT);
  Serial.println("âœ“ GPIO init");
}

void setupDisplay() {
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(C_BG);
  tft.setTextWrap(false);
  Serial.printf("âœ“ Display: %dx%d\n", tft.width(), tft.height());
}

void setupDFPlayer() {
  dfSerial.begin(9600, SERIAL_8N1, PIN_DF_RX, PIN_DF_TX);
  delay(1500);
  
  if (df.begin(dfSerial)) {
    hw_df = true;
    df.volume(cfg.volume);
    Serial.println("âœ“ DFPlayer");
  } else {
    Serial.println("âœ— DFPlayer");
  }
}

void setupRTC() {
  Wire.begin(21, 22);
  if (rtc.begin()) {
    hw_rtc = true;
    if (rtc.lostPower()) {
      rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }
    DateTime now = rtc.now();
    Serial.printf("âœ“ RTC: %02d:%02d:%02d\n", now.hour(), now.minute(), now.second());
  } else {
    Serial.println("âœ— RTC");
  }
}

void setupWiFi() {
  showScreen("CONNECTING", "WiFi...", 5, 4);
  
  WiFi.mode(WIFI_STA);
  WiFi.setHostname(MDNS_NAME);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  int tries = 0;
  while (WiFi.status() != WL_CONNECTED && tries < 30) {
    delay(500);
    tries++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    hw_wifi = true;
    buzzPattern(2, 80, 80);
    
    MDNS.begin(MDNS_NAME);
    MDNS.addService("http", "tcp", 80);
    
    Serial.printf("âœ“ WiFi: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("  mDNS: %s.local\n", MDNS_NAME);
    
    char ipBuf[20];
    sprintf(ipBuf, "%s", WiFi.localIP().toString().c_str());
    showScreen("WIFI OK", ipBuf, 5, 3);
    delay(2000);
  } else {
    Serial.println("âœ— WiFi");
    showScreen("WIFI", "OFFLINE", 5, 5);
    delay(1500);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NTP TIME SYNC â†’ RTC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupNTP() {
  configTime(GMT_OFFSET, DST_OFFSET, NTP_SERVER1, NTP_SERVER2);
  Serial.println("âœ“ NTP configured");
}

bool syncNTPtoRTC() {
  if (!hw_rtc) {
    Serial.println("No RTC for sync");
    return false;
  }
  
  // Get NTP time
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo, 5000)) {
    Serial.println("NTP fetch failed");
    return false;
  }
  
  // Save to RTC (battery backed!)
  rtc.adjust(DateTime(
    timeinfo.tm_year + 1900,
    timeinfo.tm_mon + 1,
    timeinfo.tm_mday,
    timeinfo.tm_hour,
    timeinfo.tm_min,
    timeinfo.tm_sec
  ));
  
  hw_ntp = true;
  
  DateTime now = rtc.now();
  Serial.printf("âœ“ RTC synced: %04d-%02d-%02d %02d:%02d:%02d\n",
                now.year(), now.month(), now.day(),
                now.hour(), now.minute(), now.second());
  
  addHist("NTP_SYNC", "Success");
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETTINGS (NVS)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loadSettings() {
  prefs.begin("bb", true);
  cfg.volume       = prefs.getUChar("vol", 22);
  cfg.soundOn      = prefs.getBool("snd", true);
  cfg.animOn       = prefs.getBool("anim", true);
  cfg.bootCalmMs   = prefs.getULong("bcalm", 300000);
  cfg.degradeStepMs = prefs.getULong("dstep", 300000);
  cfg.degradeStages = prefs.getUChar("dstages", 5);
  prefs.end();
  Serial.println("âœ“ Settings loaded");
}

void saveSettings() {
  prefs.begin("bb", false);
  prefs.putUChar("vol", cfg.volume);
  prefs.putBool("snd", cfg.soundOn);
  prefs.putBool("anim", cfg.animOn);
  prefs.putULong("bcalm", cfg.bootCalmMs);
  prefs.putULong("dstep", cfg.degradeStepMs);
  prefs.putUChar("dstages", cfg.degradeStages);
  prefs.end();
  Serial.println("âœ“ Settings saved");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE MACHINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void changeState(SysState s) {
  Serial.printf("State: %d â†’ %d\n", (int)sysState, (int)s);
  sysState = s;
  stateStartMs = millis();
  degradeLevel = 0;
  reminderDone = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOK READING (Non-blocking debounce)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void readBooks() {
  const uint32_t DEBOUNCE = 80;
  uint32_t now = millis();
  uint8_t studying = 0;
  
  for (int i = 0; i < 5; i++) {
    bool raw = digitalRead(books[i].pin);  // HIGH = on rack (pullup)
    
    if (raw != books[i].lastReading) {
      books[i].debounceMs = now;
      books[i].lastReading = raw;
    }
    
    if ((now - books[i].debounceMs) > DEBOUNCE) {
      if (raw != books[i].stableState) {
        books[i].stableState = raw;
        bool wasOnRack = books[i].isOnRack;
        books[i].isOnRack = raw;
        
        if (wasOnRack && !raw) {
          // Book REMOVED from rack â†’ user is studying!
          onBookRemoved(i);
        } else if (!wasOnRack && raw) {
          // Book PUT BACK on rack â†’ done studying
          onBookReturned(i);
        }
      }
    }
    
    if (!books[i].isOnRack) studying++;
  }
  
  prevStudyCount = booksBeingStudied;
  booksBeingStudied = studying;
  
  // All 5 removed (all being studied!)
  if (booksBeingStudied == 5 && prevStudyCount < 5 && !allRemovedOnce) {
    onAllBooksStudied();
  }
  if (booksBeingStudied < 5) allRemovedOnce = false;
}

void onBookRemoved(uint8_t i) {
  // Book removed = USER IS STUDYING THIS SUBJECT
  Serial.printf("ğŸ“– %s REMOVED (studying!)\n", books[i].name);
  addHist("STUDYING", books[i].name);
  
  books[i].removedEpoch = getEpoch();
  books[i].isBeingStudied = true;
  lastActivityMs = millis();
  
  // Exit degrade on activity
  if (sysState == SysState::DEGRADING || sysState == SysState::BOOT_CALM) {
    changeState(SysState::ACTIVE);
  }
  
  // Display
  showingOverlay = true;
  showBookEvent(i, true);  // true = studying
  playTrack(Audio::CHIME);
  delay(500);
  playTrack(Audio::BOOK_TIME[i]);  // "English study time" etc
  delay(2000);
  
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
}

void onBookReturned(uint8_t i) {
  // Book put back on rack â†’ session ended
  Serial.printf("ğŸ“š %s RETURNED (done)\n", books[i].name);
  
  // Calculate session time
  uint32_t sessionSecs = 0;
  if (books[i].isBeingStudied && books[i].removedEpoch > 0) {
    uint32_t now = getEpoch();
    if (now > books[i].removedEpoch) {
      sessionSecs = now - books[i].removedEpoch;
      books[i].totalStudySeconds += sessionSecs;
    }
  }
  books[i].lastSessionSecs = sessionSecs;
  books[i].isBeingStudied = false;
  books[i].removedEpoch = 0;
  lastActivityMs = millis();
  
  char detail[32];
  snprintf(detail, 32, "%s %s", books[i].name, fmtSecs(sessionSecs).c_str());
  addHist("DONE", detail);
  
  // Display
  showingOverlay = true;
  showBookEvent(i, false);  // false = returned
  playTrack(Audio::BOOK_PLACED[i]);
  delay(2000);
  
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
}

void onAllBooksStudied() {
  Serial.println("â­ ALL 5 BOOKS BEING STUDIED!");
  allRemovedOnce = true;
  addHist("ALL_STUDY", "5/5 active");
  
  showingOverlay = true;
  showAllStudying();
  playTrack(Audio::ALL_COVERED);
  delay(2000);
  playTrack(Audio::SO_PROUD);
  delay(2000);
  
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EMOTION CALCULATION - FIXED LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
 * LOGIC:
 * 
 * Happiness is based on how many books are REMOVED (being studied).
 * 0 books studying â†’ Neutral/Calm
 * 1 book  â†’ Content
 * 2 books â†’ Happy  
 * 3 books â†’ Very Happy
 * 4 books â†’ Very Happy+
 * 5 books â†’ Proud (maximum)
 *
 * DEGRADATION (no activity):
 * 0-5 min   â†’ Calm (boot calm period)
 * 5-10 min  â†’ Neutral (slightly bored)
 * 10-15 min â†’ Bored
 * 15-20 min â†’ Sad
 * 20-25 min â†’ Very Sad
 * 25+ min   â†’ Pleading + audio reminder
 */

void calcEmotion() {
  uint32_t now = millis();
  uint32_t stateElapsed = now - stateStartMs;
  uint32_t idleTime = now - lastActivityMs;
  
  switch (sysState) {
    case SysState::BOOT_CALM:
      emotion = Emotion::CALM;
      if (stateElapsed >= cfg.bootCalmMs) {
        Serial.println("Boot calm ended");
        if (booksBeingStudied > 0) {
          changeState(SysState::ACTIVE);
        } else {
          changeState(SysState::DEGRADING);
        }
      }
      break;
      
    case SysState::ACTIVE:
      // Emotion based on study count (books removed)
      emotion = studyCountToEmotion(booksBeingStudied);
      
      // If no activity for degradeStepMs, start degrading
      if (booksBeingStudied == 0 && idleTime >= cfg.degradeStepMs) {
        changeState(SysState::DEGRADING);
      }
      break;
      
    case SysState::DEGRADING: {
      // Progressive degradation based on idle time
      uint32_t totalIdle = now - lastActivityMs;
      uint8_t stage = totalIdle / cfg.degradeStepMs;
      if (stage > cfg.degradeStages) stage = cfg.degradeStages;
      degradeLevel = stage;
      
      // If user starts studying during degrade, go back to active
      if (booksBeingStudied > 0) {
        changeState(SysState::ACTIVE);
        break;
      }
      
      switch (stage) {
        case 0: emotion = Emotion::CALM;     break;  // 0-5 min
        case 1: emotion = Emotion::NEUTRAL;  break;  // 5-10 min
        case 2: emotion = Emotion::BORED;    break;  // 10-15 min
        case 3: emotion = Emotion::SAD;       break;  // 15-20 min
        case 4: emotion = Emotion::VERY_SAD;  break;  // 20-25 min
        default:
          emotion = Emotion::PLEADING;
          if (!reminderDone) {
            reminderDone = true;
            addHist("REMINDER", "Come study!");
            playTrack(Audio::MISS_YOU);
            buzzPattern(3, 200, 100);
          }
          break;
      }
      break;
    }
    
    default:
      break;
  }
}

Emotion studyCountToEmotion(uint8_t count) {
  switch (count) {
    case 0:  return Emotion::CALM;
    case 1:  return Emotion::CONTENT;
    case 2:  return Emotion::HAPPY;
    case 3:  return Emotion::VERY_HAPPY;
    case 4:  return Emotion::VERY_HAPPY;
    case 5:  return Emotion::PROUD;
    default: return Emotion::CALM;
  }
}

void emotionAudio() {
  if (!cfg.soundOn) return;
  
  // Only play on upgrades (more studying) or significant degrades
  switch (emotion) {
    case Emotion::CONTENT:   playTrack(Audio::CLICK); break;
    case Emotion::HAPPY:     playTrack(Audio::GOOD_JOB); break;
    case Emotion::VERY_HAPPY: playTrack(Audio::GREAT_PROGRESS); break;
    case Emotion::PROUD:     playTrack(Audio::DOING_AMAZING); break;
    case Emotion::BORED:     playTrack(Audio::DONT_FORGET); break;
    case Emotion::SAD:       playTrack(Audio::SAD_CHIME); break;
    case Emotion::VERY_SAD:  playTrack(Audio::UH_OH); break;
    default: break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EMOTION â†’ FACE MAPPING (FIXED - No more evil smile!)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
 * smileAmount: -100 to +100
 *   +100 = maximum smile
 *   0    = straight line
 *   -100 = maximum frown
 * 
 * mouthOpen: 0-3
 *   0 = closed mouth
 *   1 = slightly open
 *   2 = medium open
 *   3 = wide open (laughing)
 *
 * eyeOpenness: 0-34
 *   0  = closed (squinting happy)
 *   28 = normal
 *   34 = wide (surprised/sad)
 *
 * pupilY: vertical offset
 *   0  = center
 *   >0 = looking down (sad)
 */

FaceState emotionToFace(Emotion e) {
  //              eyeOpen, pupilY, smile, closed, mouthOpen
  switch (e) {
    case Emotion::CALM:       return {28,  0,  30, false, 0};
    case Emotion::CONTENT:    return {26,  0,  45, false, 0};
    case Emotion::HAPPY:      return {20, -2,  60, false, 1};
    case Emotion::VERY_HAPPY: return { 5,  0,  75, true,  1};
    case Emotion::PROUD:      return { 0,  0,  85, true,  2};
    case Emotion::NEUTRAL:    return {30,  0,   5, false, 0};
    case Emotion::BORED:      return {32,  3, -15, false, 0};
    case Emotion::SAD:        return {33,  5, -40, false, 0};
    case Emotion::VERY_SAD:   return {34,  8, -65, false, 0};
    case Emotion::PLEADING:   return {34,  6, -50, false, 0};
    default:                  return {28,  0,  30, false, 0};
  }
}

String emoStr(Emotion e) {
  switch (e) {
    case Emotion::CALM:       return "Calm";
    case Emotion::CONTENT:    return "Content";
    case Emotion::HAPPY:      return "Happy";
    case Emotion::VERY_HAPPY: return "Very Happy";
    case Emotion::PROUD:      return "Proud";
    case Emotion::NEUTRAL:    return "Neutral";
    case Emotion::BORED:      return "Bored";
    case Emotion::SAD:        return "Sad";
    case Emotion::VERY_SAD:   return "Very Sad";
    case Emotion::PLEADING:   return "Pleading";
    default:                  return "Unknown";
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOUCH SENSOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void readTouch() {
  bool reading = digitalRead(PIN_TOUCH);
  
  if (reading && !touchDown) {
    touchDown = true;
    touchDownMs = millis();
  }
  
  if (!reading && touchDown) {
    uint32_t dur = millis() - touchDownMs;
    touchDown = false;
    
    if (dur >= LONG_PRESS_MS) {
      Serial.println("ğŸ‘† Long press â†’ Stats");
      playTrack(Audio::CHIME);
      addHist("TOUCH", "long");
      showDetailedStats();
    } else if (dur > 50) {
      Serial.println("ğŸ‘† Short press â†’ Status");
      playTrack(Audio::CLICK);
      addHist("TOUCH", "short");
      lastActivityMs = millis();
      
      if (sysState == SysState::DEGRADING) {
        changeState(SysState::ACTIVE);
      }
      showQuickStatus();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DISPLAY FUNCTIONS (Professional UI)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void showScreen(const char* line1, const char* line2, uint8_t s1, uint8_t s2) {
  tft.fillScreen(C_BG);
  tft.setTextColor(C_BLACK, C_BG);
  
  if (line1) {
    tft.setTextSize(s1);
    int w = strlen(line1) * s1 * 6;
    tft.setCursor((SCR_W - w) / 2, CY - 50);
    tft.print(line1);
  }
  if (line2 && strlen(line2) > 0) {
    tft.setTextSize(s2);
    int w = strlen(line2) * s2 * 6;
    tft.setCursor((SCR_W - w) / 2, CY + 30);
    tft.print(line2);
  }
}

void showIntro() {
  showingOverlay = true;
  
  // "HEYY!"
  tft.fillScreen(C_BG);
  tft.setTextColor(C_BLACK, C_BG);
  tft.setTextSize(10);
  const char* hey = "HEYY!";
  int w = strlen(hey) * 60;
  tft.setCursor((SCR_W - w) / 2, CY - 40);
  for (int i = 0; hey[i]; i++) {
    tft.print(hey[i]);
    delay(80);
  }
  playTrack(Audio::HEY);
  delay(1500);
  
  // "I AM"
  tft.fillScreen(C_BG);
  tft.setTextSize(10);
  const char* iam = "I AM";
  w = strlen(iam) * 60;
  tft.setCursor((SCR_W - w) / 2, CY - 40);
  for (int i = 0; iam[i]; i++) {
    tft.print(iam[i]);
    delay(80);
  }
  playTrack(Audio::I_AM);
  delay(1200);
  
  // "BOOK BUDDY"
  showScreen("BOOK", "BUDDY", 8, 8);
  playTrack(Audio::BOOKBUDDY);
  delay(2000);
  
  // "YOUR STUDY PARTNER"
  showScreen("YOUR STUDY", "PARTNER", 5, 7);
  playTrack(Audio::YOUR_PARTNER);
  delay(2500);
  
  showingOverlay = false;
}

void showBookEvent(uint8_t idx, bool studying) {
  tft.fillScreen(C_BG);
  
  // Decorative top bar
  tft.fillRect(0, 0, SCR_W, 4, studying ? C_GREEN : C_AMBER);
  
  tft.setTextColor(C_BLACK, C_BG);
  
  // Book name - large
  String name = books[idx].name;
  name.toUpperCase();
  tft.setTextSize(6);
  int w = name.length() * 36;
  tft.setCursor((SCR_W - w) / 2, 60);
  tft.print(name);
  
  // Status line
  if (studying) {
    tft.setTextSize(4);
    const char* msg = "STUDYING!";
    w = strlen(msg) * 24;
    tft.setCursor((SCR_W - w) / 2, 130);
    tft.setTextColor(C_GREEN, C_BG);
    tft.print(msg);
  } else {
    tft.setTextSize(4);
    const char* msg = "DONE!";
    w = strlen(msg) * 24;
    tft.setCursor((SCR_W - w) / 2, 130);
    tft.setTextColor(C_AMBER, C_BG);
    tft.print(msg);
    
    // Show session time
    tft.setTextColor(C_BLACK, C_BG);
    String timeStr = "Session: " + fmtSecs(books[idx].lastSessionSecs);
    tft.setTextSize(3);
    w = timeStr.length() * 18;
    tft.setCursor((SCR_W - w) / 2, 190);
    tft.print(timeStr);
    
    // Total time
    String totalStr = "Total: " + fmtSecs(getBookSecs(idx));
    w = totalStr.length() * 18;
    tft.setCursor((SCR_W - w) / 2, 230);
    tft.print(totalStr);
  }
  
  // Count indicator at bottom
  tft.setTextColor(C_BLACK, C_BG);
  tft.setTextSize(2);
  char countBuf[30];
  sprintf(countBuf, "Studying: %d / 5 subjects", booksBeingStudied);
  w = strlen(countBuf) * 12;
  tft.setCursor((SCR_W - w) / 2, 285);
  tft.print(countBuf);
}

void showAllStudying() {
  tft.fillScreen(C_BG);
  tft.fillRect(0, 0, SCR_W, 4, C_GREEN);
  tft.fillRect(0, SCR_H - 4, SCR_W, 4, C_GREEN);
  tft.setTextColor(C_BLACK, C_BG);
  
  tft.setTextSize(5);
  const char* l1 = "ALL BOOKS";
  tft.setCursor((SCR_W - strlen(l1) * 30) / 2, 50);
  tft.print(l1);
  
  tft.setTextSize(6);
  tft.setTextColor(C_GREEN, C_BG);
  const char* l2 = "STUDYING!";
  tft.setCursor((SCR_W - strlen(l2) * 36) / 2, 120);
  tft.print(l2);
  
  tft.setTextColor(C_BLACK, C_BG);
  tft.setTextSize(4);
  const char* l3 = "SO PROUD!";
  tft.setCursor((SCR_W - strlen(l3) * 24) / 2, 200);
  tft.print(l3);
}

void showQuickStatus() {
  showingOverlay = true;
  tft.fillScreen(C_BG);
  
  // Header bar
  tft.fillRect(0, 0, SCR_W, 50, C_DBLUE);
  tft.setTextColor(C_WHITE, C_DBLUE);
  tft.setTextSize(3);
  const char* title = "BOOKBUDDY STATUS";
  int w = strlen(title) * 18;
  tft.setCursor((SCR_W - w) / 2, 14);
  tft.print(title);
  
  tft.setTextColor(C_BLACK, C_BG);
  int y = 65;
  
  // Time
  if (hw_rtc) {
    DateTime now = rtc.now();
    char buf[20];
    sprintf(buf, "%02d:%02d:%02d", now.hour(), now.minute(), now.second());
    drawInfoRow(y, "TIME", buf, 3);
    y += 48;
  }
  
  // Books studying
  char bookBuf[20];
  sprintf(bookBuf, "%d / 5", booksBeingStudied);
  drawInfoRow(y, "STUDYING", bookBuf, 3);
  y += 48;
  
  // Total time
  uint32_t total = 0;
  for (int i = 0; i < 5; i++) total += getBookSecs(i);
  drawInfoRow(y, "TOTAL", fmtSecs(total).c_str(), 3);
  y += 48;
  
  // Emotion
  drawInfoRow(y, "MOOD", emoStr(emotion).c_str(), 3);
  
  // Footer
  if (hw_wifi) {
    tft.setTextSize(2);
    tft.setTextColor(C_LGRAY, C_BG);
    String ipStr = WiFi.localIP().toString();
    w = ipStr.length() * 12;
    tft.setCursor((SCR_W - w) / 2, 290);
    tft.print(ipStr);
  }
  
  delay(3000);
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
}

void drawInfoRow(int y, const char* label, const char* value, uint8_t sz) {
  tft.setTextSize(sz);
  tft.setTextColor(C_LGRAY, C_BG);
  tft.setCursor(30, y);
  tft.print(label);
  
  tft.setTextColor(C_BLACK, C_BG);
  int w = strlen(value) * sz * 6;
  tft.setCursor(SCR_W - w - 30, y);
  tft.print(value);
  
  // Separator
  tft.drawFastHLine(30, y + sz * 8 + 6, SCR_W - 60, C_DBLUE);
}

void showDetailedStats() {
  showingOverlay = true;
  tft.fillScreen(C_BG);
  
  // Header
  tft.fillRect(0, 0, SCR_W, 50, C_DBLUE);
  tft.setTextColor(C_WHITE, C_DBLUE);
  tft.setTextSize(3);
  const char* title = "STUDY PROGRESS";
  int w = strlen(title) * 18;
  tft.setCursor((SCR_W - w) / 2, 14);
  tft.print(title);
  
  // Each subject
  int y = 60;
  int barW = SCR_W - 80;
  
  // Find max for scaling
  uint32_t maxSecs = 1;
  for (int i = 0; i < 5; i++) {
    uint32_t s = getBookSecs(i);
    if (s > maxSecs) maxSecs = s;
  }
  
  uint16_t barColors[5] = {
    tft.color565(59, 130, 246),   // Blue
    tft.color565(34, 197, 94),    // Green
    tft.color565(245, 158, 11),   // Amber
    tft.color565(168, 85, 247),   // Purple
    tft.color565(239, 68, 68)     // Red
  };
  
  for (int i = 0; i < 5; i++) {
    uint32_t secs = getBookSecs(i);
    
    // Status icon + name
    tft.setTextColor(C_BLACK, C_BG);
    tft.setTextSize(2);
    
    // Active indicator
    if (books[i].isBeingStudied) {
      tft.fillCircle(25, y + 8, 5, C_GREEN);
    } else {
      tft.drawCircle(25, y + 8, 5, C_LGRAY);
    }
    
    tft.setCursor(40, y);
    tft.print(books[i].name);
    
    // Time value
    String ts = fmtSecs(secs);
    int tw = ts.length() * 12;
    tft.setCursor(SCR_W - tw - 20, y);
    tft.print(ts);
    
    // Progress bar
    int barY = y + 22;
    tft.fillRoundRect(40, barY, barW, 10, 5, C_DBLUE);
    int fillW = (secs * barW) / maxSecs;
    if (fillW > 2) {
      tft.fillRoundRect(40, barY, fillW, 10, 5, barColors[i]);
    }
    
    y += 46;
  }
  
  // Total at bottom
  uint32_t total = 0;
  for (int i = 0; i < 5; i++) total += getBookSecs(i);
  
  tft.setTextColor(C_BLACK, C_BG);
  tft.setTextSize(3);
  String totalStr = "Total: " + fmtSecs(total);
  w = totalStr.length() * 18;
  tft.setCursor((SCR_W - w) / 2, 295);
  tft.print(totalStr);
  
  delay(5000);
  tft.fillScreen(C_BG);
  drawFullFace();
  showingOverlay = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACE RENDERING - COMPLETELY FIXED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void drawFullFace() {
  drawCheeks();
  drawEyes();
  drawMouth();
}

void drawCheeks() {
  tft.fillCircle(CX - F_CHEEK_X, CY + F_CHEEK_Y, F_CHEEK_R, C_PINK);
  tft.fillCircle(CX + F_CHEEK_X, CY + F_CHEEK_Y, F_CHEEK_R, C_PINK);
}

void drawEyes() {
  int ey = CY + F_EYE_Y;
  drawOneEye(CX - F_EYE_SPACE, ey, face.eyesClosed);
  drawOneEye(CX + F_EYE_SPACE, ey, face.eyesClosed);
}

void drawOneEye(int x, int y, bool closed) {
  if (closed) {
    // Happy squint - curved line (NOT a frown)
    int hw = 28;
    for (int t = -2; t <= 2; t++) {
      for (int i = -hw; i <= hw; i++) {
        float n = (float)i / hw;
        // Upward curve (happy squint) - arch shape
        int cy = (int)(-abs(n) * 12 + 12);  // Makes âˆ© shape
        tft.drawPixel(x + i, y + cy + t, C_BLACK);
      }
    }
  } else {
    // Open eye
    tft.fillCircle(x, y, F_EYE_R, C_WHITE);
    tft.drawCircle(x, y, F_EYE_R, C_LGRAY);
    
    // Pupil with vertical offset
    int py = y + face.pupilY;
    tft.fillCircle(x, py, F_PUPIL_R, C_BLACK);
    
    // Highlight reflections
    tft.fillCircle(x - 5, py - 5, 5, C_WHITE);
    tft.fillCircle(x - 8, py - 8, 2, C_WHITE);
    
    // Eyelid effect for half-closed eyes
    if (face.eyeOpenness < 20) {
      int lidDrop = map(face.eyeOpenness, 0, 20, F_EYE_R, 0);
      tft.fillRect(x - F_EYE_R - 1, y - F_EYE_R - 1, 
                    (F_EYE_R + 1) * 2, lidDrop, C_BG);
    }
  }
}

void clearEyeRegion() {
  int ey = CY + F_EYE_Y;
  int r = F_EYE_R + 6;
  tft.fillRect(CX - F_EYE_SPACE - r, ey - r, r * 2, r * 2, C_BG);
  tft.fillRect(CX + F_EYE_SPACE - r, ey - r, r * 2, r * 2, C_BG);
  drawCheeks();  // Redraw cheeks that may overlap
}

void clearMouthRegion() {
  tft.fillRect(CX - F_MOUTH_W - 35, CY + F_MOUTH_Y - 35,
               (F_MOUTH_W + 35) * 2, 90, C_BG);
}

void drawMouth() {
  int cx = CX;
  int cy = CY + F_MOUTH_Y;
  int w  = F_MOUTH_W;
  int smile = face.smileAmount;  // -100 to +100
  int openLevel = face.mouthOpen;
  
  if (smile > 0) {
    // â•â•â• SMILE â•â•â•
    // Map smile (0-100) to curve depth (0-25 pixels)
    int depth = map(constrain(smile, 0, 100), 0, 100, 0, 25);
    
    // Draw smile curve (U shape, opening downward = smile)
    for (int t = -2; t <= 2; t++) {
      for (int i = -w; i <= w; i++) {
        float n = (float)i / w;
        // Parabola: y = depth * n^2 - makes a U shape
        int py = cy + (int)(n * n * depth) + t;
        tft.drawPixel(cx + i, py, C_BLACK);
      }
    }
    
    // Open mouth for higher happiness
    if (openLevel >= 1 && depth > 10) {
      // Fill inside the smile curve
      int fillR = map(openLevel, 1, 3, 10, 22);
      int mouthCenterY = cy + depth / 2 + 5;
      tft.fillCircle(cx, mouthCenterY, fillR, C_BLACK);
      
      // Tongue (red inside)
      if (openLevel >= 2) {
        int tongueR = fillR - 4;
        tft.fillCircle(cx, mouthCenterY + 4, tongueR, C_RED);
      }
    }
    
  } else if (smile < 0) {
    // â•â•â• FROWN â•â•â•
    int depth = map(constrain(-smile, 0, 100), 0, 100, 0, 20);
    
    // Draw frown (âˆ© shape)
    for (int t = -2; t <= 2; t++) {
      for (int i = -w; i <= w; i++) {
        float n = (float)i / w;
        // Inverted parabola for frown
        int py = cy - (int)(n * n * depth) + t;
        tft.drawPixel(cx + i, py, C_BLACK);
      }
    }
    
    // Wobble lip for very sad
    if (smile < -50) {
      // Small circle at center of frown
      int wobY = cy - depth - 3;
      tft.fillCircle(cx, wobY, 6, C_BLACK);
    }
    
  } else {
    // â•â•â• NEUTRAL: straight line â•â•â•
    for (int t = -2; t <= 2; t++) {
      tft.drawFastHLine(cx - w, cy + t, w * 2, C_BLACK);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACE ANIMATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void animateFace() {
  if (millis() - lastAnimMs < 50) return;
  lastAnimMs = millis();
  
  FaceState old = face;
  
  // Smooth interpolation
  face.eyeOpenness  += constrain(faceTarget.eyeOpenness - face.eyeOpenness, -2, 2);
  face.pupilY       += constrain(faceTarget.pupilY - face.pupilY, -1, 1);
  face.smileAmount  += constrain(faceTarget.smileAmount - face.smileAmount, -3, 3);
  face.eyesClosed    = faceTarget.eyesClosed;
  face.mouthOpen     = faceTarget.mouthOpen;
  
  bool eyeChg = (face.eyeOpenness != old.eyeOpenness || 
                  face.pupilY != old.pupilY ||
                  face.eyesClosed != old.eyesClosed);
  bool mthChg = (face.smileAmount != old.smileAmount ||
                  face.mouthOpen != old.mouthOpen);
  
  if (eyeChg) { clearEyeRegion(); drawEyes(); }
  if (mthChg) { clearMouthRegion(); drawMouth(); }
}

void blinkCheck() {
  if (face.eyesClosed) return;
  if (millis() - lastBlinkMs > 3500) {
    lastBlinkMs = millis();
    
    clearEyeRegion();
    int ey = CY + F_EYE_Y;
    drawOneEye(CX - F_EYE_SPACE, ey, true);
    drawOneEye(CX + F_EYE_SPACE, ey, true);
    delay(100);
    clearEyeRegion();
    drawEyes();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

uint32_t getEpoch() {
  if (hw_rtc) return rtc.now().unixtime();
  return millis() / 1000;
}

uint32_t getBookSecs(uint8_t i) {
  uint32_t total = books[i].totalStudySeconds;
  if (books[i].isBeingStudied && books[i].removedEpoch > 0) {
    uint32_t now = getEpoch();
    if (now > books[i].removedEpoch) {
      total += (now - books[i].removedEpoch);
    }
  }
  return total;
}

String fmtSecs(uint32_t s) {
  uint32_t h = s / 3600;
  uint32_t m = (s % 3600) / 60;
  uint32_t sec = s % 60;
  char buf[20];
  if (h > 0) sprintf(buf, "%dh %dm", h, m);
  else if (m > 0) sprintf(buf, "%dm %ds", m, sec);
  else sprintf(buf, "%ds", sec);
  return String(buf);
}

void playTrack(uint8_t t) {
  if (hw_df && cfg.soundOn) df.playMp3Folder(t);
}

void buzzPattern(uint8_t count, uint16_t onMs, uint16_t offMs) {
  for (uint8_t i = 0; i < count; i++) {
    digitalWrite(PIN_BUZZER, HIGH);
    delay(onMs);
    digitalWrite(PIN_BUZZER, LOW);
    if (offMs > 0 && i < count - 1) delay(offMs);
  }
}

void addHist(const char* ev, const char* det) {
  HistEvent& e = hist[histHead];
  e.epoch = getEpoch();
  strncpy(e.event, ev, 19); e.event[19] = 0;
  strncpy(e.detail, det, 31); e.detail[31] = 0;
  histHead = (histHead + 1) % HIST_MAX;
  if (histCount < HIST_MAX) histCount++;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  JSON BUILDERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

String buildStatusJson() {
  StaticJsonDocument<1536> doc;
  
  doc["fw"] = FW_VERSION;
  doc["up"] = millis() / 1000;
  doc["heap"] = ESP.getFreeHeap();
  doc["emo"] = emoStr(emotion);
  doc["state"] = (int)sysState;
  doc["studying"] = booksBeingStudied;
  doc["degrade"] = degradeLevel;
  
  if (hw_rtc) {
    DateTime now = rtc.now();
    char buf[25];
    sprintf(buf, "%04d-%02d-%02dT%02d:%02d:%02d",
            now.year(), now.month(), now.day(),
            now.hour(), now.minute(), now.second());
    doc["time"] = buf;
  } else {
    doc["time"] = "N/A";
  }
  
  JsonObject hw = doc.createNestedObject("hw");
  hw["rtc"] = hw_rtc;
  hw["df"] = hw_df;
  hw["wifi"] = hw_wifi;
  hw["ntp"] = hw_ntp;
  hw["rssi"] = WiFi.RSSI();
  
  JsonArray bArr = doc.createNestedArray("books");
  uint32_t totalStudy = 0;
  for (int i = 0; i < 5; i++) {
    JsonObject b = bArr.createNestedObject();
    b["n"] = books[i].name;
    b["s"] = !books[i].isOnRack;  // studying = not on rack
    b["t"] = getBookSecs(i);
    totalStudy += getBookSecs(i);
  }
  doc["total"] = totalStudy;
  
  JsonObject t = doc.createNestedObject("timing");
  t["idle"] = millis() - lastActivityMs;
  t["stateMs"] = millis() - stateStartMs;
  
  JsonObject s = doc.createNestedObject("cfg");
  s["vol"] = cfg.volume;
  s["snd"] = cfg.soundOn;
  s["bcalm"] = cfg.bootCalmMs;
  s["dstep"] = cfg.degradeStepMs;
  s["dstages"] = cfg.degradeStages;
  
  String out;
  serializeJson(doc, out);
  return out;
}

String buildHistJson() {
  StaticJsonDocument<4096> doc;
  JsonArray arr = doc.createNestedArray("hist");
  
  int idx = (histHead - histCount + HIST_MAX) % HIST_MAX;
  for (int i = 0; i < histCount; i++) {
    JsonObject e = arr.createNestedObject();
    e["t"] = hist[idx].epoch;
    e["e"] = hist[idx].event;
    e["d"] = hist[idx].detail;
    idx = (idx + 1) % HIST_MAX;
  }
  
  String out;
  serializeJson(doc, out);
  return out;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEBSOCKET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupWebSocket() {
  ws.onEvent([](AsyncWebSocket* srv, AsyncWebSocketClient* cli,
                AwsEventType type, void* arg, uint8_t* data, size_t len) {
    if (type == WS_EVT_CONNECT) {
      Serial.printf("WS[%u] connected\n", cli->id());
      cli->text(buildStatusJson());
    } 
    else if (type == WS_EVT_DISCONNECT) {
      Serial.printf("WS[%u] disconnected\n", cli->id());
    }
    else if (type == WS_EVT_DATA) {
      AwsFrameInfo* info = (AwsFrameInfo*)arg;
      if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
        String msg;
        for (size_t i = 0; i < len; i++) msg += (char)data[i];
        
        StaticJsonDocument<256> cmd;
        if (deserializeJson(cmd, msg) == DeserializationError::Ok) {
          handleWsCmd(cli, cmd);
        }
      }
    }
  });
  webServer.addHandler(&ws);
  Serial.println("âœ“ WebSocket /ws");
}

void handleWsCmd(AsyncWebSocketClient* cli, StaticJsonDocument<256>& doc) {
  const char* c = doc["cmd"];
  if (!c) return;
  
  if (strcmp(c, "ping") == 0) {
    cli->text("{\"cmd\":\"pong\"}");
  }
  else if (strcmp(c, "status") == 0) {
    cli->text(buildStatusJson());
  }
  else if (strcmp(c, "hist") == 0) {
    cli->text(buildHistJson());
  }
  else if (strcmp(c, "syncTime") == 0) {
    bool ok = syncNTPtoRTC();
    if (ok) {
      playTrack(Audio::TIME_SYNCED);
      cli->text("{\"cmd\":\"ok\",\"act\":\"syncTime\"}");
    } else {
      // Fallback: use epoch from client
      uint32_t epoch = doc["epoch"] | 0;
      if (hw_rtc && epoch > 1000000000) {
        rtc.adjust(DateTime(epoch));
        addHist("SYNC", "Manual epoch");
        playTrack(Audio::TIME_SYNCED);
        cli->text("{\"cmd\":\"ok\",\"act\":\"syncTime\",\"src\":\"manual\"}");
      } else {
        cli->text("{\"cmd\":\"err\",\"msg\":\"NTP failed, no epoch\"}");
      }
    }
  }
  else if (strcmp(c, "vol") == 0) {
    cfg.volume = constrain(doc["v"] | 22, 0, 30);
    if (hw_df) df.volume(cfg.volume);
    saveSettings();
    cli->text("{\"cmd\":\"ok\",\"act\":\"vol\"}");
  }
  else if (strcmp(c, "snd") == 0) {
    cfg.soundOn = doc["v"] | true;
    saveSettings();
    cli->text("{\"cmd\":\"ok\",\"act\":\"snd\"}");
  }
  else if (strcmp(c, "reset") == 0) {
    for (int i = 0; i < 5; i++) {
      books[i].totalStudySeconds = 0;
      books[i].lastSessionSecs = 0;
    }
    addHist("RESET", "Timers cleared");
    cli->text("{\"cmd\":\"ok\",\"act\":\"reset\"}");
  }
  else if (strcmp(c, "play") == 0) {
    int t = doc["t"] | 0;
    if (t > 0) playTrack(t);
    cli->text("{\"cmd\":\"ok\"}");
  }
  else if (strcmp(c, "buzz") == 0) {
    buzzPattern(2, 200, 100);
    cli->text("{\"cmd\":\"ok\"}");
  }
  else if (strcmp(c, "cfg") == 0) {
    if (doc.containsKey("bcalm")) cfg.bootCalmMs = doc["bcalm"];
    if (doc.containsKey("dstep")) cfg.degradeStepMs = doc["dstep"];
    if (doc.containsKey("dstages")) cfg.degradeStages = doc["dstages"];
    saveSettings();
    cli->text("{\"cmd\":\"ok\",\"act\":\"cfg\"}");
  }
}

void broadcastWs() {
  if (!hw_wifi || ws.count() == 0) return;
  if (millis() - lastWsMs < 2000) return;
  lastWsMs = millis();
  ws.textAll(buildStatusJson());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEB SERVER + EMBEDDED DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupWebServer() {
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Headers", "Content-Type");
  
  // Main dashboard
  webServer.on("/", HTTP_GET, serveDashboard);
  
  // REST API
  webServer.on("/api/status", HTTP_GET, [](AsyncWebServerRequest* r) {
    r->send(200, "application/json", buildStatusJson());
  });
  
  webServer.on("/api/history", HTTP_GET, [](AsyncWebServerRequest* r) {
    r->send(200, "application/json", buildHistJson());
  });
  
  webServer.on("/api/sync", HTTP_POST, [](AsyncWebServerRequest* r) {
    bool ok = syncNTPtoRTC();
    r->send(200, "application/json", ok ? 
      "{\"ok\":true,\"src\":\"NTP\"}" : "{\"ok\":false,\"msg\":\"NTP failed\"}");
  });
  
  webServer.on("/api/sync", HTTP_POST, [](AsyncWebServerRequest* r){}, NULL,
    [](AsyncWebServerRequest* r, uint8_t* data, size_t len, size_t idx, size_t total) {
      // Try NTP first
      if (syncNTPtoRTC()) {
        r->send(200, "application/json", "{\"ok\":true,\"src\":\"NTP\"}");
        return;
      }
      // Fallback to client epoch
      String body;
      for (size_t i = 0; i < len; i++) body += (char)data[i];
      StaticJsonDocument<128> doc;
      if (deserializeJson(doc, body) == DeserializationError::Ok) {
        uint32_t epoch = doc["epoch"] | 0;
        if (hw_rtc && epoch > 1000000000) {
          rtc.adjust(DateTime(epoch));
          addHist("SYNC", "Client epoch");
          r->send(200, "application/json", "{\"ok\":true,\"src\":\"client\"}");
          return;
        }
      }
      r->send(400, "application/json", "{\"ok\":false}");
    }
  );
  
  webServer.on("/api/reset", HTTP_POST, [](AsyncWebServerRequest* r) {
    for (int i = 0; i < 5; i++) {
      books[i].totalStudySeconds = 0;
      books[i].lastSessionSecs = 0;
    }
    addHist("RESET", "API");
    r->send(200, "application/json", "{\"ok\":true}");
  });
  
  webServer.on("/api/info", HTTP_GET, [](AsyncWebServerRequest* r) {
    StaticJsonDocument<256> d;
    d["dev"] = DEVICE_NAME;
    d["fw"] = FW_VERSION;
    d["chip"] = ESP.getChipModel();
    d["mhz"] = ESP.getCpuFreqMHz();
    d["heap"] = ESP.getFreeHeap();
    d["up"] = millis() / 1000;
    d["ip"] = WiFi.localIP().toString();
    d["rssi"] = WiFi.RSSI();
    d["mac"] = WiFi.macAddress();
    String out; serializeJson(d, out);
    r->send(200, "application/json", out);
  });
  
  // OTA
  webServer.on("/update", HTTP_POST,
    [](AsyncWebServerRequest* r) {
      bool ok = !Update.hasError();
      r->send(200, "application/json", ok ? "{\"ok\":true}" : "{\"ok\":false}");
      if (ok) { delay(1000); ESP.restart(); }
    },
    [](AsyncWebServerRequest* r, const String& fn, size_t idx, uint8_t* data, size_t len, bool final) {
      if (!idx) Update.begin(UPDATE_SIZE_UNKNOWN);
      Update.write(data, len);
      if (final) Update.end(true);
    }
  );
  
  webServer.begin();
  Serial.printf("âœ“ Server: http://%s/ | http://%s.local/\n", 
                WiFi.localIP().toString().c_str(), MDNS_NAME);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FULL EMBEDDED DASHBOARD (Single Page Application)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void serveDashboard(AsyncWebServerRequest* req) {
  
  String html = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BookBuddy Dashboard</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0f172a;--c1:#1e293b;--c2:#334155;--c3:#475569;
--a:#3b82f6;--a2:#60a5fa;--g:#22c55e;--r:#ef4444;--y:#f59e0b;--p:#a855f7;
--t:#f1f5f9;--t2:#94a3b8;--rd:14px}
body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--t);min-height:100vh}
.wrap{max-width:1200px;margin:0 auto;padding:12px}

/* Header */
.hdr{text-align:center;padding:20px 0 12px}
.hdr h1{font-size:2em;font-weight:800;background:linear-gradient(135deg,var(--a2),var(--p));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hdr .sub{color:var(--t2);font-size:.9em;margin-top:2px}
.badge{display:inline-flex;align-items:center;gap:6px;padding:5px 14px;border-radius:20px;font-size:.8em;font-weight:600;margin-top:6px}
.badge.on{background:#22c55e22;color:var(--g);border:1px solid #22c55e44}
.badge.off{background:#ef444422;color:var(--r);border:1px solid #ef444444}
.dot{width:8px;height:8px;border-radius:50%;background:currentColor;animation:pls 2s infinite}
@keyframes pls{0%,100%{opacity:1}50%{opacity:.4}}

/* Tabs */
.tabs{display:flex;gap:3px;margin:12px 0;background:var(--c1);border-radius:12px;padding:3px;border:1px solid var(--c3)}
.tb{flex:1;padding:10px;text-align:center;border-radius:9px;cursor:pointer;font-weight:600;font-size:.88em;color:var(--t2);transition:.2s}
.tb.on{background:var(--a);color:#fff}.tb:hover:not(.on){background:var(--c2)}

/* Grid */
.g{display:grid;gap:14px;margin-top:14px}
.g2{grid-template-columns:1fr 1fr}
.g3{grid-template-columns:1fr 1fr 1fr}
.g5{grid-template-columns:repeat(5,1fr)}
@media(max-width:900px){.g3,.g5{grid-template-columns:1fr 1fr}}
@media(max-width:600px){.g2,.g3,.g5{grid-template-columns:1fr}}

/* Card */
.cd{background:var(--c1);border-radius:var(--rd);padding:18px;border:1px solid var(--c3);transition:.2s}
.cd:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,.3)}
.cd h3{font-size:.82em;color:var(--t2);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px}
.cd .val{font-size:2em;font-weight:700}
.cd .det{font-size:.78em;color:var(--t2);margin-top:3px}

/* Emotion */
.emo-cd{text-align:center;padding:24px}
.emo-face{font-size:3.8em;margin-bottom:6px}
.emo-name{font-size:1.4em;font-weight:700}

/* Book cards */
.bk{position:relative;overflow:hidden}
.bk.act{border-color:var(--g)}
.bk.act::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:var(--g)}
.bk .sdot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px;transition:.3s}
.bk .sdot.on{background:var(--g);box-shadow:0 0 8px var(--g)}
.bk .sdot.off{background:var(--c3)}
.bk .bn{font-size:1em;font-weight:600}
.bk .bt{font-size:1.4em;font-weight:700;margin-top:6px;font-variant-numeric:tabular-nums}
.bk .bs{font-size:.75em;color:var(--t2);margin-top:3px}

/* Progress */
.pbar{height:8px;background:var(--c2);border-radius:4px;overflow:hidden;margin-top:6px}
.pfill{height:100%;border-radius:4px;transition:width .5s}

/* History */
.hlist{max-height:400px;overflow-y:auto}
.hlist::-webkit-scrollbar{width:5px}
.hlist::-webkit-scrollbar-track{background:var(--c2);border-radius:3px}
.hlist::-webkit-scrollbar-thumb{background:var(--c3);border-radius:3px}
.hi{display:flex;align-items:center;gap:10px;padding:9px;border-radius:8px;margin-bottom:3px;background:var(--c2);font-size:.88em}
.hi .ic{font-size:1.1em;min-width:24px;text-align:center}
.hi .ht{color:var(--t2);font-size:.78em;min-width:50px}
.hi .he{font-weight:600}
.hi .hd{color:var(--t2);margin-left:auto;font-size:.85em}

/* Buttons */
.btn{padding:11px 18px;border:none;border-radius:11px;font-size:.92em;font-weight:600;cursor:pointer;transition:.2s;display:flex;align-items:center;justify-content:center;gap:7px;color:var(--t);width:100%}
.btn:hover{transform:translateY(-1px)}.btn:active{transform:scale(.97)}
.btn-a{background:var(--a)}.btn-g{background:var(--g)}.btn-y{background:var(--y);color:#000}
.btn-r{background:var(--r)}.btn-p{background:var(--p)}.btn-o{background:var(--c2);border:1px solid var(--c3)}
.cg{display:grid;grid-template-columns:1fr 1fr;gap:10px}
@media(max-width:600px){.cg{grid-template-columns:1fr}}

/* Settings */
.sr{display:flex;align-items:center;justify-content:space-between;padding:13px 0;border-bottom:1px solid var(--c2)}
.sr:last-child{border-bottom:none}
.sr .sl{font-weight:500}
.sr .sl small{display:block;color:var(--t2);font-weight:400;font-size:.78em;margin-top:1px}
.sw{display:flex;align-items:center;gap:10px}
input[type=range]{-webkit-appearance:none;width:140px;height:5px;border-radius:3px;background:var(--c2);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--a);cursor:pointer}
.tgl{position:relative;width:44px;height:24px;cursor:pointer}
.tgl input{opacity:0;width:0;height:0}
.tgl .sldr{position:absolute;inset:0;background:var(--c2);border-radius:12px;transition:.3s}
.tgl .sldr::before{content:'';position:absolute;width:18px;height:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:.3s}
.tgl input:checked+.sldr{background:var(--g)}
.tgl input:checked+.sldr::before{transform:translateX(20px)}

/* HW */
.hw{display:flex;align-items:center;gap:8px;padding:6px 0;font-size:.9em}
.hwd{width:9px;height:9px;border-radius:50%}
.hwd.ok{background:var(--g)}.hwd.no{background:var(--r)}

/* Toast */
.toast{position:fixed;bottom:20px;right:20px;padding:12px 22px;border-radius:11px;font-weight:600;font-size:.88em;transform:translateY(100px);opacity:0;transition:.3s;z-index:999}
.toast.show{transform:translateY(0);opacity:1}
.toast.ok{background:var(--g);color:#fff}.toast.er{background:var(--r);color:#fff}.toast.in{background:var(--a);color:#fff}

.ft{text-align:center;padding:16px;color:var(--t2);font-size:.75em;margin-top:20px}
.fi{animation:fi .4s ease}
@keyframes fi{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
</style>
</head>
<body>
<div class="wrap">

<div class="hdr fi">
  <h1>ğŸ“š BookBuddy</h1>
  <div class="sub">Smart Study Companion</div>
  <div id="badge" class="badge off"><span class="dot"></span><span id="connTxt">Connecting...</span></div>
</div>

<div class="tabs fi">
  <div class="tb on" onclick="tab('dash')">ğŸ“Š Dashboard</div>
  <div class="tb" onclick="tab('hist')">ğŸ“œ History</div>
  <div class="tb" onclick="tab('ctrl')">ğŸ® Controls</div>
  <div class="tb" onclick="tab('sett')">âš™ï¸ Settings</div>
</div>

<!-- â•â•â• DASHBOARD â•â•â• -->
<div id="p-dash">
<div class="g g3 fi">
  <div class="cd emo-cd">
    <div class="emo-face" id="eFace">ğŸ˜Š</div>
    <div class="emo-name" id="eName">--</div>
    <div class="det" id="eState">--</div>
  </div>
  <div class="cd" style="text-align:center">
    <h3>Studying</h3>
    <div class="val" id="sCount">-</div>
    <div class="det">of 5 subjects</div>
    <div class="pbar" style="margin-top:10px"><div class="pfill" id="sProg" style="width:0%;background:linear-gradient(90deg,var(--a),var(--g))"></div></div>
  </div>
  <div class="cd" style="text-align:center">
    <h3>Total Study</h3>
    <div class="val" id="tStudy">--</div>
    <div class="det" id="clock">--:--:--</div>
  </div>
</div>

<div class="g g5 fi" style="margin-top:14px">
  <div class="cd bk" id="b0"><span class="sdot off" id="d0"></span><span class="bn">English</span><div class="bt" id="t0">0s</div><div class="bs" id="s0">On rack</div></div>
  <div class="cd bk" id="b1"><span class="sdot off" id="d1"></span><span class="bn">Hindi</span><div class="bt" id="t1">0s</div><div class="bs" id="s1">On rack</div></div>
  <div class="cd bk" id="b2"><span class="sdot off" id="d2"></span><span class="bn">Maths</span><div class="bt" id="t2">0s</div><div class="bs" id="s2">On rack</div></div>
  <div class="cd bk" id="b3"><span class="sdot off" id="d3"></span><span class="bn">Marathi</span><div class="bt" id="t3">0s</div><div class="bs" id="s3">On rack</div></div>
  <div class="cd bk" id="b4"><span class="sdot off" id="d4"></span><span class="bn">Science</span><div class="bt" id="t4">0s</div><div class="bs" id="s4">On rack</div></div>
</div>

<div class="g g2 fi" style="margin-top:14px">
  <div class="cd">
    <h3>Hardware</h3>
    <div class="hw"><span class="hwd" id="hRtc"></span> RTC DS3231</div>
    <div class="hw"><span class="hwd" id="hDf"></span> DFPlayer Audio</div>
    <div class="hw"><span class="hwd" id="hWifi"></span> WiFi</div>
    <div class="hw"><span class="hwd" id="hNtp"></span> NTP Synced</div>
    <div style="margin-top:10px;font-size:.82em;color:var(--t2)">
      <div>FW: <span id="xFw">--</span></div>
      <div>Uptime: <span id="xUp">--</span></div>
      <div>Heap: <span id="xHeap">--</span></div>
      <div>RSSI: <span id="xRssi">--</span> dBm</div>
    </div>
  </div>
  <div class="cd">
    <h3>Subject Progress</h3>
    <div id="progBars"></div>
  </div>
</div>
</div>

<!-- â•â•â• HISTORY â•â•â• -->
<div id="p-hist" style="display:none">
<div class="cd fi">
  <h3>Event History</h3>
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
    <span id="hCount" style="color:var(--t2);font-size:.88em">Loading...</span>
    <button class="btn btn-o" onclick="send('hist')" style="width:auto;padding:7px 14px;font-size:.82em">ğŸ”„ Refresh</button>
  </div>
  <div class="hlist" id="hList"><div style="text-align:center;padding:30px;color:var(--t2)">Waiting...</div></div>
</div>
</div>

<!-- â•â•â• CONTROLS â•â•â• -->
<div id="p-ctrl" style="display:none">
<div class="cd fi">
  <h3>Remote Controls</h3>
  <div class="cg" style="margin-top:14px">
    <button class="btn btn-a" onclick="send('status')">ğŸ“Š Get Status</button>
    <button class="btn btn-g" onclick="doSync()">ğŸ• Sync Time (NTP)</button>
    <button class="btn btn-y" onclick="send('buzz')">ğŸ”” Buzz</button>
    <button class="btn btn-p" onclick="send('play',{t:34})">ğŸµ Play Chime</button>
    <button class="btn btn-r" onclick="doReset()">ğŸ—‘ï¸ Reset Timers</button>
    <button class="btn btn-o" onclick="send('hist')">ğŸ“œ Get History</button>
  </div>
</div>
<div class="cd fi" style="margin-top:14px">
  <h3>Audio Test</h3>
  <div class="cg" style="margin-top:10px">
    <button class="btn btn-o" onclick="send('play',{t:1})">Hey!</button>
    <button class="btn btn-o" onclick="send('play',{t:3})">BookBuddy</button>
    <button class="btn btn-o" onclick="send('play',{t:5})">Time to Study</button>
    <button class="btn btn-o" onclick="send('play',{t:31})">Good Job</button>
    <button class="btn btn-o" onclick="send('play',{t:36})">I Miss You</button>
    <button class="btn btn-o" onclick="send('play',{t:38})">Doing Amazing</button>
    <button class="btn btn-o" onclick="send('play',{t:42})">So Proud</button>
    <button class="btn btn-o" onclick="send('play',{t:43})">Take a Break</button>
  </div>
</div>
<div class="cd fi" style="margin-top:14px">
  <h3>OTA Firmware Update</h3>
  <form id="otaF">
    <input type="file" id="otaFile" accept=".bin" style="margin-bottom:10px;color:var(--t)">
    <button type="submit" class="btn btn-y">ğŸ“¦ Upload Firmware</button>
  </form>
  <div id="otaP" style="display:none;margin-top:10px"><div class="pbar" style="height:12px"><div class="pfill" id="otaBar" style="width:0%;background:var(--y)"></div></div></div>
</div>
</div>

<!-- â•â•â• SETTINGS â•â•â• -->
<div id="p-sett" style="display:none">
<div class="cd fi">
  <h3>Device Settings</h3>
  <div class="sr">
    <div class="sl">Volume<small>Speaker (0-30)</small></div>
    <div class="sw"><span id="vVal">22</span><input type="range" min="0" max="30" value="22" id="vSldr" oninput="document.getElementById('vVal').textContent=this.value;send('vol',{v:+this.value})"></div>
  </div>
  <div class="sr">
    <div class="sl">Sound<small>Audio on/off</small></div>
    <label class="tgl"><input type="checkbox" checked id="sndTgl" onchange="send('snd',{v:this.checked})"><span class="sldr"></span></label>
  </div>
  <div class="sr">
    <div class="sl">Boot Calm<small>Minutes calm at startup</small></div>
    <div class="sw"><span id="bcV">5</span> min<input type="range" min="1" max="30" value="5" id="bcS" oninput="document.getElementById('bcV').textContent=this.value"></div>
  </div>
  <div class="sr">
    <div class="sl">Degrade Step<small>Minutes between stages</small></div>
    <div class="sw"><span id="dsV">5</span> min<input type="range" min="1" max="30" value="5" id="dsS" oninput="document.getElementById('dsV').textContent=this.value"></div>
  </div>
  <div class="sr">
    <div class="sl">Degrade Stages<small>Number of stages</small></div>
    <div class="sw"><span id="dgV">5</span><input type="range" min="3" max="10" value="5" id="dgS" oninput="document.getElementById('dgV').textContent=this.value"></div>
  </div>
  <button class="btn btn-a" onclick="saveCfg()" style="margin-top:14px">ğŸ’¾ Save All Settings</button>
</div>
</div>

<div class="ft">BookBuddy V1 Â· <span id="xIp">--</span> Â· <span id="xWs">Disconnected</span></div>
</div>

<div class="toast" id="toast"></div>

<script>
let ws=null,connected=false,recon=null,hb=null;

function connect(){
  const h=location.hostname||'bookbuddy.local';
  try{ws=new WebSocket('ws://'+h+'/ws')}catch(e){sched();return}
  ws.onopen=()=>{connected=true;ui(true);clearTimeout(recon);
    hb=setInterval(()=>{if(ws&&ws.readyState===1)ws.send('{"cmd":"ping"}')},12000)};
  ws.onmessage=e=>{try{const d=JSON.parse(e.data);
    if(d.cmd==='pong')return;
    if(d.hist){renderH(d.hist);return}
    if(d.cmd==='ok'||d.cmd==='err'){toast(d.cmd==='ok'?'âœ“ '+(d.act||'OK'):'âœ— '+(d.msg||'Error'),d.cmd==='ok'?'ok':'er');return}
    upd(d)}catch(x){}};
  ws.onclose=()=>{connected=false;ui(false);clearInterval(hb);sched()};
  ws.onerror=()=>ws.close();
}
function sched(){clearTimeout(recon);recon=setTimeout(connect,3000)}
function send(c,x){if(!ws||ws.readyState!==1){toast('Not connected','er');return}ws.send(JSON.stringify({cmd:c,...x}))}
function ui(on){
  document.getElementById('badge').className='badge '+(on?'on':'off');
  document.getElementById('connTxt').textContent=on?'Connected':'Reconnecting...';
  document.getElementById('xWs').textContent='WS: '+(on?'Connected':'Disconnected');
}

const EM={
  Calm:{f:'ğŸ˜Š',c:'var(--a2)'},Content:{f:'ğŸ™‚',c:'var(--a2)'},
  Happy:{f:'ğŸ˜„',c:'var(--g)'},'Very Happy':{f:'ğŸ˜†',c:'var(--g)'},
  Proud:{f:'ğŸ¤©',c:'var(--y)'},Neutral:{f:'ğŸ˜',c:'var(--t2)'},
  Bored:{f:'ğŸ˜‘',c:'var(--y)'},Sad:{f:'ğŸ˜Ÿ',c:'var(--y)'},
  'Very Sad':{f:'ğŸ˜¢',c:'var(--r)'},Pleading:{f:'ğŸ¥º',c:'var(--r)'}
};
const SN=['Booting','Intro','Boot Calm','Active','Degrading','Overlay'];

function upd(d){
  const em=EM[d.emo]||{f:'â“',c:'var(--t2)'};
  el('eFace').textContent=em.f;
  el('eName').textContent=d.emo||'--';
  el('eName').style.color=em.c;
  el('eState').textContent=(SN[d.state]||'?')+(d.degrade>0?' (stage '+d.degrade+')':'');
  el('sCount').textContent=d.studying+' / 5';
  el('sProg').style.width=(d.studying/5*100)+'%';
  el('tStudy').textContent=fmt(d.total||0);
  if(d.time&&d.time!=='N/A'){const t=d.time.split('T')[1]||d.time;el('clock').textContent='ğŸ• '+t}
  
  if(d.books){
    let pb='';const mx=Math.max(...d.books.map(b=>b.t),1);
    const cs=['var(--a)','var(--g)','var(--y)','var(--p)','var(--r)'];
    d.books.forEach((b,i)=>{
      const c=el('b'+i),dot=el('d'+i),tm=el('t'+i),st=el('s'+i);
      if(c)c.className='cd bk'+(b.s?' act':'');
      if(dot)dot.className='sdot '+(b.s?'on':'off');
      if(tm)tm.textContent=fmt(b.t);
      if(st)st.textContent=b.s?'ğŸ“– Studying':'ğŸ“š On rack';
      const pct=mx>0?(b.t/mx*100):0;
      pb+='<div style="margin-bottom:7px"><div style="display:flex;justify-content:space-between;font-size:.82em;margin-bottom:2px"><span>'+b.n+'</span><span>'+fmt(b.t)+'</span></div><div class="pbar"><div class="pfill" style="width:'+pct+'%;background:'+cs[i]+'"></div></div></div>';
    });
    el('progBars').innerHTML=pb;
  }
  
  if(d.hw){hw('hRtc',d.hw.rtc);hw('hDf',d.hw.df);hw('hWifi',d.hw.wifi);hw('hNtp',d.hw.ntp);
    if(d.hw.rssi!=null)el('xRssi').textContent=d.hw.rssi}
  if(d.fw)el('xFw').textContent=d.fw;
  if(d.up!=null)el('xUp').textContent=fmt(d.up);
  if(d.heap!=null)el('xHeap').textContent=(d.heap/1024).toFixed(1)+' KB';
  el('xIp').textContent=location.hostname;
  
  if(d.cfg){
    el('vSldr').value=d.cfg.vol;el('vVal').textContent=d.cfg.vol;
    el('sndTgl').checked=d.cfg.snd;
    el('bcS').value=d.cfg.bcalm/60000;el('bcV').textContent=d.cfg.bcalm/60000;
    el('dsS').value=d.cfg.dstep/60000;el('dsV').textContent=d.cfg.dstep/60000;
    el('dgS').value=d.cfg.dstages;el('dgV').textContent=d.cfg.dstages;
  }
}

function hw(id,ok){const e=document.getElementById(id);if(e)e.className='hwd '+(ok?'ok':'no')}

function renderH(items){
  el('hCount').textContent=items.length+' events';
  if(!items.length){el('hList').innerHTML='<div style="text-align:center;padding:30px;color:var(--t2)">No events</div>';return}
  const ic={BOOT:'ğŸš€',STUDYING:'ğŸ“–',DONE:'âœ…',ALL_STUDY:'â­',TOUCH:'ğŸ‘†',REMINDER:'â°',RESET:'ğŸ—‘ï¸',NTP_SYNC:'ğŸ•',SYNC:'ğŸ•'};
  let h='';items.slice().reverse().forEach(e=>{
    const d=new Date(e.t*1000);const ts=d.getHours().toString().padStart(2,'0')+':'+d.getMinutes().toString().padStart(2,'0');
    h+='<div class="hi"><span class="ic">'+(ic[e.e]||'ğŸ“‹')+'</span><span class="ht">'+ts+'</span><span class="he">'+e.e+'</span><span class="hd">'+(e.d||'')+'</span></div>';
  });
  el('hList').innerHTML=h;
}

function doSync(){send('syncTime');toast('Syncing via NTP...','in')}
function doReset(){if(confirm('Reset all study timers?'))send('reset')}
function saveCfg(){
  send('cfg',{bcalm:+el('bcS').value*60000,dstep:+el('dsS').value*60000,dstages:+el('dgS').value});
  toast('Settings saved!','ok');
}

function tab(n){
  ['dash','hist','ctrl','sett'].forEach(t=>el('p-'+t).style.display=t===n?'':'none');
  document.querySelectorAll('.tb').forEach(e=>e.classList.remove('on'));
  event.target.classList.add('on');
  if(n==='hist')send('hist');
}

document.getElementById('otaF').addEventListener('submit',function(e){
  e.preventDefault();const f=document.getElementById('otaFile').files[0];
  if(!f){toast('Select .bin file','er');return}
  const x=new XMLHttpRequest(),fd=new FormData();fd.append('update',f);
  el('otaP').style.display='block';
  x.upload.onprogress=e=>{if(e.lengthComputable)el('otaBar').style.width=(e.loaded/e.total*100).toFixed(0)+'%'};
  x.onload=()=>{toast(x.status===200?'Done! Rebooting...':'Failed',x.status===200?'ok':'er');if(x.status===200)setTimeout(()=>location.reload(),5000)};
  x.open('POST','/update');x.send(fd);
});

function el(id){return document.getElementById(id)}
function fmt(s){if(s==null||s<0)return'--';const h=Math.floor(s/3600),m=Math.floor(s%3600/60),sc=s%60;return h>0?h+'h '+m+'m':m>0?m+'m '+sc+'s':sc+'s'}
function toast(m,t){const e=el('toast');e.textContent=m;e.className='toast '+t+' show';setTimeout(()=>e.className='toast',3000)}

setInterval(()=>fetch('/api/info').then(r=>r.json()).then(d=>{if(d.rssi!=null)el('xRssi').textContent=d.rssi}).catch(()=>{}),10000);

connect();
</script>
</body>
</html>
)rawliteral";

  req->send(200, "text/html", html);
}
