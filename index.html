/*
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘              BookBuddy V1 - Production Firmware             â•‘
 * â•‘                                                              â•‘
 * â•‘  Complete rewrite with:                                      â•‘
 * â•‘  âœ“ Robust WebSocket with heartbeat & reconnection           â•‘
 * â•‘  âœ“ Full REST API (status, settings, commands, history)      â•‘
 * â•‘  âœ“ Embedded full-fledge dashboard (no external hosting)     â•‘
 * â•‘  âœ“ mDNS support (bookbuddy.local)                          â•‘
 * â•‘  âœ“ Persistent settings via Preferences                     â•‘
 * â•‘  âœ“ Proper state machine with clean transitions              â•‘
 * â•‘  âœ“ Non-blocking everything                                  â•‘
 * â•‘  âœ“ Detailed logging & error handling                        â•‘
 * â•‘  âœ“ OTA update support                                       â•‘
 * â•‘                                                              â•‘
 * â•‘  Display: ILI9488 480x320 Landscape                         â•‘
 * â•‘  Pins: See PIN DEFINITIONS section                          â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

#include <Wire.h>
#include <RTClib.h>
#include <SPI.h>
#include <TFT_eSPI.h>
#include <DFRobotDFPlayerMini.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ESPmDNS.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <Update.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const char* WIFI_SSID     = "20";
const char* WIFI_PASS     = "12345678";
const char* MDNS_NAME     = "bookbuddy";
const char* FIRMWARE_VER  = "1.0.0";
const char* DEVICE_NAME   = "BookBuddy";

// â”€â”€ Pin Definitions â”€â”€
#define BTN_ENGLISH    12
#define BTN_HINDI      14
#define BTN_MATHS      25
#define BTN_MARATHI    32
#define BTN_SCIENCE    33
#define TOUCH_SENSOR   4
#define DFPLAYER_RX    5
#define DFPLAYER_TX    18
#define BUZZER_PIN     26

// â”€â”€ Audio File Indices â”€â”€
namespace Audio {
  const uint8_t HEY            = 1;
  const uint8_t I_AM            = 2;
  const uint8_t BOOKBUDDY      = 3;
  const uint8_t YOUR_PARTNER   = 4;
  const uint8_t TIME_TO_STUDY  = 5;
  const uint8_t BOOK_PLACED[5] = {11, 12, 13, 14, 15};
  const uint8_t BOOK_TIME[5]   = {21, 22, 23, 24, 25};
  const uint8_t ALL_READY      = 30;
  const uint8_t GOOD_JOB       = 31;
  const uint8_t WELL_DONE      = 32;
  const uint8_t UH_OH          = 33;
  const uint8_t CHIME          = 34;
  const uint8_t CLICK          = 35;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TYPE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum class Emotion : uint8_t {
  NEUTRAL, CALM, HAPPY, PROUD, VERY_PROUD,
  SAD, VERY_SAD, REMINDER
};

enum class SystemState : uint8_t {
  BOOTING,
  INTRO,
  BOOT_CALM,
  ACTIVE,
  CALM_HOLD,
  DEGRADING,
  OVERLAY
};

struct BookData {
  const char*  name;
  uint8_t      pin;
  bool         present;
  bool         lastStableState;
  uint32_t     lastDebounceTime;
  uint32_t     placedEpoch;
  uint32_t     cumulativeSeconds;
  bool         tracking;
  uint32_t     sessionSeconds;  // Current session only
};

struct Settings {
  uint32_t bootCalmMs;
  uint32_t calmHoldMs;
  uint32_t degradeIntervalMs;
  uint8_t  degradeStages;
  uint8_t  volume;
  uint32_t longPressMs;
  bool     soundEnabled;
  bool     animationEnabled;
};

struct FaceParams {
  int  eyeOpen;
  int  pupilOffset;
  int  mouthCurve;
  bool eyesClosed;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GLOBAL OBJECTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TFT_eSPI            tft = TFT_eSPI();
RTC_DS3231           rtc;
HardwareSerial       dfSerial(1);
DFRobotDFPlayerMini  dfPlayer;
AsyncWebServer       server(80);
AsyncWebSocket       ws("/ws");
Preferences          prefs;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DISPLAY CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define CLR_BG       0x1E9F  // Blue background
#define CLR_BLACK    0x0000
#define CLR_WHITE    0xFFFF
#define CLR_PINK     tft.color565(255, 182, 193)
#define CLR_RED      tft.color565(255, 100, 100)
#define CLR_GRAY     tft.color565(200, 200, 200)
#define CLR_GREEN    0x07E0

const int SCREEN_W     = 480;
const int SCREEN_H     = 320;
const int CENTER_X     = 240;
const int CENTER_Y     = 160;

// Face geometry
const int EYE_SPACING    = 70;
const int EYE_Y_OFFSET   = -30;
const int EYE_RADIUS     = 34;
const int PUPIL_RADIUS   = 14;
const int CHEEK_RADIUS   = 20;
const int CHEEK_X_OFFSET = 110;
const int CHEEK_Y_OFFSET = 25;
const int MOUTH_Y        = 60;
const int MOUTH_WIDTH    = 55;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE VARIABLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BookData books[5] = {
  {"English", BTN_ENGLISH, false, false, 0, 0, 0, false, 0},
  {"Hindi",   BTN_HINDI,   false, false, 0, 0, 0, false, 0},
  {"Maths",   BTN_MATHS,   false, false, 0, 0, 0, false, 0},
  {"Marathi", BTN_MARATHI, false, false, 0, 0, 0, false, 0},
  {"Science", BTN_SCIENCE, false, false, 0, 0, 0, false, 0}
};

Settings settings = {
  .bootCalmMs       = 300000,   // 5 min
  .calmHoldMs       = 300000,   // 5 min
  .degradeIntervalMs = 300000,  // 5 min per stage
  .degradeStages    = 5,
  .volume           = 22,
  .longPressMs      = 2000,
  .soundEnabled     = true,
  .animationEnabled = true
};

// System state
SystemState  sysState          = SystemState::BOOTING;
Emotion      currentEmotion    = Emotion::CALM;
Emotion      prevEmotion       = Emotion::CALM;
uint8_t      bookCount         = 0;
uint8_t      prevBookCount     = 0;
bool         allBooksAnnounced = false;

// Timing
uint32_t stateEnteredAt    = 0;
uint32_t lastInteraction   = 0;
uint8_t  degradeStage      = 0;
bool     reminderPlayed    = false;

// Touch
bool     touchActive       = false;
uint32_t touchStartMs      = 0;

// Face animation
FaceParams currentFace = {28, 0, 5, false};
FaceParams targetFace  = {28, 0, 5, false};
uint32_t   lastFrameMs = 0;
uint32_t   lastBlinkMs = 0;
bool       overlayShowing = false;

// Hardware status
bool hw_dfplayer = false;
bool hw_rtc      = false;
bool hw_wifi     = false;

// WebSocket
uint32_t lastWsBroadcast = 0;
uint32_t wsClientCount   = 0;

// Session tracking
uint32_t sessionStartEpoch = 0;
uint32_t todayStudySeconds = 0;

// History buffer (last 24 entries)
struct HistoryEntry {
  uint32_t epoch;
  char     event[32];
  char     detail[32];
};
#define HISTORY_SIZE 50
HistoryEntry history[HISTORY_SIZE];
int historyHead = 0;
int historyCount = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FORWARD DECLARATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initHardware();
void initDisplay();
void initDFPlayer();
void initRTC();
void initWiFi();
void initWebServer();
void initWebSocket();
void loadSettings();
void saveSettings();

void changeState(SystemState newState);
void updateBooks();
void updateEmotion();
void updateTouch();
void updateFaceAnimation();
void updateWebSocket();

void drawFaceFull();
void drawEyes();
void drawMouth();
void drawCheeks();
void clearEyes();
void clearMouth();
void drawSingleEye(int x, int y, bool closed);

void showText(const char* l1, const char* l2, uint8_t s1, uint8_t s2);
void showIntroSequence();
void showBookEvent(uint8_t idx, bool placed);
void showAllBooksEvent();
void showQuickStatus();
void showDetailedStats();

void playAudio(uint8_t track);
void buzz(uint16_t onMs, uint16_t offMs = 0, uint8_t repeats = 1);
void addHistory(const char* event, const char* detail);

uint32_t getEpoch();
uint32_t getBookSeconds(uint8_t i);
String   formatSeconds(uint32_t s);
String   emotionToString(Emotion e);
FaceParams emotionToFace(Emotion e);
String   buildStatusJson();

// Embedded dashboard
void serveMainPage(AsyncWebServerRequest* req);
void serveCSS(AsyncWebServerRequest* req);
void serveJS(AsyncWebServerRequest* req);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.println();
  Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘     BookBuddy V1 - Starting Up       â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  loadSettings();
  initHardware();
  initDisplay();
  initDFPlayer();
  initRTC();
  initWiFi();

  if (hw_wifi) {
    initWebSocket();
    initWebServer();
  }

  sessionStartEpoch = getEpoch();
  addHistory("BOOT", FIRMWARE_VER);

  // Intro sequence
  changeState(SystemState::INTRO);
  showIntroSequence();

  // Enter boot calm
  changeState(SystemState::BOOT_CALM);
  currentEmotion = Emotion::CALM;
  targetFace = emotionToFace(Emotion::CALM);
  currentFace = targetFace;

  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;

  Serial.println("\nâœ“ BookBuddy V1 Ready!");
  Serial.printf("  Free heap: %d bytes\n", ESP.getFreeHeap());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loop() {
  if (hw_wifi) ws.cleanupClients();

  updateBooks();
  updateTouch();
  updateEmotion();

  // Emotion change handler
  if (currentEmotion != prevEmotion) {
    Serial.printf("Emotion: %s â†’ %s\n",
                  emotionToString(prevEmotion).c_str(),
                  emotionToString(currentEmotion).c_str());
    targetFace = emotionToFace(currentEmotion);
    onEmotionChanged();
    prevEmotion = currentEmotion;
  }

  if (!overlayShowing && settings.animationEnabled) {
    updateFaceAnimation();
    handleBlink();
  }

  updateWebSocket();

  delay(25);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initHardware() {
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  buzz(150);

  for (int i = 0; i < 5; i++) {
    pinMode(books[i].pin, INPUT_PULLUP);
  }
  pinMode(TOUCH_SENSOR, INPUT);

  Serial.println("âœ“ GPIO initialized");
}

void initDisplay() {
  tft.init();
  tft.setRotation(1);  // Landscape 480x320
  tft.fillScreen(CLR_BG);
  Serial.printf("âœ“ Display: %dx%d\n", tft.width(), tft.height());
}

void initDFPlayer() {
  dfSerial.begin(9600, SERIAL_8N1, DFPLAYER_RX, DFPLAYER_TX);
  delay(1500);

  if (dfPlayer.begin(dfSerial)) {
    hw_dfplayer = true;
    dfPlayer.volume(settings.volume);
    Serial.println("âœ“ DFPlayer ready");
  } else {
    Serial.println("âœ— DFPlayer not found");
  }
}

void initRTC() {
  Wire.begin(21, 22);
  if (rtc.begin()) {
    hw_rtc = true;
    if (rtc.lostPower()) {
      rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
      Serial.println("  RTC was reset to compile time");
    }
    DateTime now = rtc.now();
    Serial.printf("âœ“ RTC: %02d:%02d:%02d\n", now.hour(), now.minute(), now.second());
  } else {
    Serial.println("âœ— RTC not found");
  }
}

void initWiFi() {
  showText("CONNECTING", "WiFi...", 5, 4);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  uint8_t tries = 0;
  while (WiFi.status() != WL_CONNECTED && tries < 30) {
    delay(500);
    Serial.print(".");
    tries++;
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    hw_wifi = true;
    buzz(80, 80, 2);

    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
      Serial.printf("âœ“ mDNS: %s.local\n", MDNS_NAME);
    }

    Serial.printf("âœ“ WiFi: %s\n", WiFi.localIP().toString().c_str());

    char ipStr[20];
    sprintf(ipStr, "%s", WiFi.localIP().toString().c_str());
    showText("WiFi OK", ipStr, 5, 3);
    delay(2000);
  } else {
    Serial.println("âœ— WiFi failed");
    showText("WiFi", "OFFLINE", 5, 5);
    delay(1500);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETTINGS PERSISTENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loadSettings() {
  prefs.begin("bbv1", true);
  settings.volume       = prefs.getUChar("vol", 22);
  settings.soundEnabled = prefs.getBool("snd", true);
  settings.bootCalmMs   = prefs.getULong("bcalm", 300000);
  settings.calmHoldMs   = prefs.getULong("chold", 300000);
  settings.degradeIntervalMs = prefs.getULong("dgint", 300000);
  prefs.end();
  Serial.println("âœ“ Settings loaded");
}

void saveSettings() {
  prefs.begin("bbv1", false);
  prefs.putUChar("vol", settings.volume);
  prefs.putBool("snd", settings.soundEnabled);
  prefs.putULong("bcalm", settings.bootCalmMs);
  prefs.putULong("chold", settings.calmHoldMs);
  prefs.putULong("dgint", settings.degradeIntervalMs);
  prefs.end();
  Serial.println("Settings saved");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE MACHINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void changeState(SystemState newState) {
  Serial.printf("State: %d â†’ %d\n", (int)sysState, (int)newState);
  sysState = newState;
  stateEnteredAt = millis();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOK STATE MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateBooks() {
  const uint32_t DEBOUNCE_MS = 80;
  uint32_t now = millis();
  uint8_t count = 0;

  for (int i = 0; i < 5; i++) {
    bool raw = !digitalRead(books[i].pin);

    // Debounce
    if (raw != books[i].lastStableState) {
      if (now - books[i].lastDebounceTime < DEBOUNCE_MS) {
        // Still within debounce window, use last stable
        if (books[i].present) count++;
        continue;
      }
      books[i].lastDebounceTime = now;
    }

    bool stableState = raw;

    // Detect transitions
    if (stableState != books[i].present) {
      books[i].present = stableState;
      books[i].lastStableState = stableState;
      lastInteraction = now;

      if (stableState) {
        onBookPlaced(i);
      } else {
        onBookRemoved(i);
      }
    }

    if (books[i].present) count++;
  }

  prevBookCount = bookCount;
  bookCount = count;

  // All 5 books placed event
  if (bookCount == 5 && prevBookCount < 5 && !allBooksAnnounced) {
    onAllBooksPlaced();
  }
  if (bookCount < 5) allBooksAnnounced = false;
}

void onBookPlaced(uint8_t idx) {
  Serial.printf("ğŸ“— %s PLACED\n", books[idx].name);
  addHistory("PLACED", books[idx].name);

  books[idx].placedEpoch = getEpoch();
  books[idx].tracking = true;
  books[idx].sessionSeconds = 0;

  // Exit degrade/calm on interaction
  if (sysState == SystemState::BOOT_CALM ||
      sysState == SystemState::CALM_HOLD ||
      sysState == SystemState::DEGRADING) {
    changeState(SystemState::ACTIVE);
  }

  // Display announcement
  overlayShowing = true;
  showBookEvent(idx, true);
  playAudio(Audio::CHIME);
  delay(600);
  playAudio(Audio::BOOK_PLACED[idx]);
  delay(1800);

  // Restore face
  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;
}

void onBookRemoved(uint8_t idx) {
  Serial.printf("ğŸ“• %s REMOVED\n", books[idx].name);

  // Accumulate time
  if (books[idx].tracking && books[idx].placedEpoch > 0) {
    uint32_t elapsed = getEpoch() - books[idx].placedEpoch;
    books[idx].cumulativeSeconds += elapsed;
    books[idx].sessionSeconds = elapsed;
    Serial.printf("   Session: %ds, Total: %ds\n", elapsed, books[idx].cumulativeSeconds);
  }
  books[idx].tracking = false;
  books[idx].placedEpoch = 0;

  char detail[32];
  snprintf(detail, sizeof(detail), "%s %ds", books[idx].name, books[idx].sessionSeconds);
  addHistory("REMOVED", detail);

  if (sysState == SystemState::CALM_HOLD ||
      sysState == SystemState::DEGRADING) {
    changeState(SystemState::ACTIVE);
  }

  overlayShowing = true;
  showBookEvent(idx, false);
  playAudio(Audio::BOOK_TIME[idx]);
  delay(2000);

  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;
}

void onAllBooksPlaced() {
  Serial.println("â­ ALL 5 BOOKS PLACED!");
  allBooksAnnounced = true;
  addHistory("ALL_PLACED", "5/5");

  overlayShowing = true;
  showAllBooksEvent();
  playAudio(Audio::ALL_READY);
  delay(2000);
  playAudio(Audio::WELL_DONE);
  delay(2000);

  // Start calm hold â†’ will degrade after timeout
  changeState(SystemState::CALM_HOLD);
  reminderPlayed = false;
  degradeStage = 0;

  currentEmotion = Emotion::CALM;
  targetFace = emotionToFace(Emotion::CALM);
  currentFace = targetFace;

  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;
}

void onEmotionChanged() {
  if (!settings.soundEnabled) return;

  switch (currentEmotion) {
    case Emotion::HAPPY:  playAudio(Audio::GOOD_JOB); break;
    case Emotion::PROUD:  playAudio(Audio::WELL_DONE); break;
    case Emotion::SAD:    playAudio(Audio::UH_OH); break;
    default: break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EMOTION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateEmotion() {
  uint32_t now = millis();
  uint32_t elapsed = now - stateEnteredAt;

  switch (sysState) {
    case SystemState::BOOT_CALM:
      currentEmotion = Emotion::CALM;
      if (elapsed >= settings.bootCalmMs) {
        Serial.println("Boot calm ended");
        changeState(SystemState::ACTIVE);
      }
      break;

    case SystemState::CALM_HOLD:
      currentEmotion = Emotion::CALM;
      if (elapsed >= settings.calmHoldMs) {
        Serial.println("Calm hold â†’ Degrading");
        changeState(SystemState::DEGRADING);
      }
      break;

    case SystemState::DEGRADING: {
      uint8_t stage = elapsed / settings.degradeIntervalMs;
      if (stage > settings.degradeStages) stage = settings.degradeStages;
      degradeStage = stage;

      switch (stage) {
        case 0: currentEmotion = Emotion::CALM;     break;
        case 1: currentEmotion = Emotion::NEUTRAL;  break;
        case 2: currentEmotion = Emotion::NEUTRAL;  break;
        case 3: currentEmotion = Emotion::SAD;       break;
        case 4: currentEmotion = Emotion::VERY_SAD;  break;
        default:
          currentEmotion = Emotion::REMINDER;
          if (!reminderPlayed) {
            reminderPlayed = true;
            addHistory("REMINDER", "Time to study!");
            playAudio(Audio::TIME_TO_STUDY);
            buzz(200, 100, 3);
          }
          break;
      }
      break;
    }

    case SystemState::ACTIVE:
      // Emotion based on book count
      switch (bookCount) {
        case 0:  currentEmotion = Emotion::NEUTRAL; break;
        case 1:
        case 2:  currentEmotion = Emotion::CALM;    break;
        case 3:
        case 4:  currentEmotion = Emotion::HAPPY;   break;
        case 5:  currentEmotion = Emotion::PROUD;   break;
      }
      break;

    default:
      break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOUCH HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateTouch() {
  bool reading = digitalRead(TOUCH_SENSOR);

  if (reading && !touchActive) {
    touchActive = true;
    touchStartMs = millis();
  }

  if (!reading && touchActive) {
    uint32_t duration = millis() - touchStartMs;
    touchActive = false;

    if (duration >= settings.longPressMs) {
      Serial.println("ğŸ‘† Long press â†’ Stats");
      playAudio(Audio::CHIME);
      addHistory("TOUCH", "long press");
      showDetailedStats();
    } else if (duration > 50) {
      Serial.println("ğŸ‘† Short press â†’ Status");
      playAudio(Audio::CLICK);
      addHistory("TOUCH", "short press");
      lastInteraction = millis();

      if (sysState == SystemState::DEGRADING || sysState == SystemState::CALM_HOLD) {
        changeState(SystemState::ACTIVE);
        reminderPlayed = false;
      }
      showQuickStatus();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DISPLAY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void showText(const char* l1, const char* l2, uint8_t s1, uint8_t s2) {
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);

  if (l1) {
    tft.setTextSize(s1);
    int w = strlen(l1) * s1 * 6;
    tft.setCursor((SCREEN_W - w) / 2, CENTER_Y - 50);
    tft.print(l1);
  }
  if (l2 && strlen(l2) > 0) {
    tft.setTextSize(s2);
    int w = strlen(l2) * s2 * 6;
    tft.setCursor((SCREEN_W - w) / 2, CENTER_Y + 30);
    tft.print(l2);
  }
}

void showIntroSequence() {
  overlayShowing = true;

  // "HEYY!"
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);
  tft.setTextSize(10);
  const char* hey = "HEYY!";
  int w = strlen(hey) * 60;
  int x = (SCREEN_W - w) / 2;
  tft.setCursor(x, CENTER_Y - 40);
  for (int i = 0; hey[i]; i++) {
    tft.print(hey[i]);
    delay(80);
  }
  playAudio(Audio::HEY);
  delay(1500);

  // "I AM"
  tft.fillScreen(CLR_BG);
  tft.setTextSize(10);
  const char* iam = "I AM";
  w = strlen(iam) * 60;
  tft.setCursor((SCREEN_W - w) / 2, CENTER_Y - 40);
  for (int i = 0; iam[i]; i++) {
    tft.print(iam[i]);
    delay(80);
  }
  playAudio(Audio::I_AM);
  delay(1200);

  // "BOOK BUDDY"
  showText("BOOK", "BUDDY", 8, 8);
  playAudio(Audio::BOOKBUDDY);
  delay(2000);

  // "YOUR STUDY PARTNER"
  showText("YOUR STUDY", "PARTNER", 5, 7);
  playAudio(Audio::YOUR_PARTNER);
  delay(2500);

  overlayShowing = false;
}

void showBookEvent(uint8_t idx, bool placed) {
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);

  // Book name
  String name = books[idx].name;
  name.toUpperCase();
  tft.setTextSize(6);
  int w = name.length() * 36;
  tft.setCursor((SCREEN_W - w) / 2, CENTER_Y - 60);
  tft.print(name);

  // Action
  const char* action = placed ? "PLACED!" : "REMOVED";
  tft.setTextSize(6);
  w = strlen(action) * 36;
  tft.setCursor((SCREEN_W - w) / 2, CENTER_Y + 20);
  tft.print(action);

  if (!placed) {
    String timeStr = "Time: " + formatSeconds(getBookSeconds(idx));
    tft.setTextSize(3);
    w = timeStr.length() * 18;
    tft.setCursor((SCREEN_W - w) / 2, CENTER_Y + 90);
    tft.print(timeStr);
  }
}

void showAllBooksEvent() {
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);

  tft.setTextSize(5);
  const char* l1 = "ALL BOOKS";
  tft.setCursor((SCREEN_W - strlen(l1) * 30) / 2, CENTER_Y - 80);
  tft.print(l1);

  tft.setTextSize(7);
  const char* l2 = "PLACED!";
  tft.setCursor((SCREEN_W - strlen(l2) * 42) / 2, CENTER_Y - 10);
  tft.print(l2);

  tft.setTextSize(4);
  const char* l3 = "WELL DONE!";
  tft.setCursor((SCREEN_W - strlen(l3) * 24) / 2, CENTER_Y + 70);
  tft.print(l3);
}

void showQuickStatus() {
  overlayShowing = true;
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);

  tft.setTextSize(5);
  const char* title = "GREAT JOB!";
  tft.setCursor((SCREEN_W - strlen(title) * 30) / 2, 15);
  tft.print(title);

  tft.drawFastHLine(30, 65, SCREEN_W - 60, CLR_BLACK);

  if (hw_rtc) {
    DateTime now = rtc.now();
    char buf[30];
    sprintf(buf, "Time: %02d:%02d:%02d", now.hour(), now.minute(), now.second());
    tft.setTextSize(3);
    tft.setCursor((SCREEN_W - strlen(buf) * 18) / 2, 80);
    tft.print(buf);
  }

  char bookBuf[20];
  sprintf(bookBuf, "Books: %d / 5", bookCount);
  tft.setTextSize(4);
  tft.setCursor((SCREEN_W - strlen(bookBuf) * 24) / 2, 130);
  tft.print(bookBuf);

  uint32_t total = 0;
  for (int i = 0; i < 5; i++) total += getBookSeconds(i);
  String totalStr = "Study: " + formatSeconds(total);
  tft.setTextSize(4);
  tft.setCursor((SCREEN_W - totalStr.length() * 24) / 2, 200);
  tft.print(totalStr);

  if (hw_wifi) {
    String ipStr = "IP: " + WiFi.localIP().toString();
    tft.setTextSize(2);
    tft.setCursor((SCREEN_W - ipStr.length() * 12) / 2, 270);
    tft.print(ipStr);
  }

  delay(3000);
  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;
}

void showDetailedStats() {
  overlayShowing = true;
  tft.fillScreen(CLR_BG);
  tft.setTextColor(CLR_BLACK, CLR_BG);

  tft.setTextSize(4);
  const char* title = "TODAY'S PROGRESS";
  tft.setCursor((SCREEN_W - strlen(title) * 24) / 2, 10);
  tft.print(title);

  tft.drawFastHLine(15, 55, SCREEN_W - 30, CLR_BLACK);

  tft.setTextSize(3);
  int yPos = 70;

  for (int i = 0; i < 5; i++) {
    uint32_t secs = getBookSeconds(i);
    String timeStr = formatSeconds(secs);

    if (books[i].present) {
      tft.fillCircle(25, yPos + 10, 6, CLR_GREEN);
    } else {
      tft.drawCircle(25, yPos + 10, 6, CLR_BLACK);
    }

    tft.setCursor(45, yPos);
    tft.print(books[i].name);
    tft.print(":");

    int tw = timeStr.length() * 18;
    tft.setCursor(SCREEN_W - tw - 30, yPos);
    tft.print(timeStr);

    yPos += 42;
  }

  tft.setTextSize(3);
  const char* tip = "KEEP GOING!";
  tft.setCursor((SCREEN_W - strlen(tip) * 18) / 2, 290);
  tft.print(tip);

  delay(5000);
  tft.fillScreen(CLR_BG);
  drawFaceFull();
  overlayShowing = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACE RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void drawFaceFull() {
  drawCheeks();
  drawEyes();
  drawMouth();
}

void drawCheeks() {
  tft.fillCircle(CENTER_X - CHEEK_X_OFFSET, CENTER_Y + CHEEK_Y_OFFSET, CHEEK_RADIUS, CLR_PINK);
  tft.fillCircle(CENTER_X + CHEEK_X_OFFSET, CENTER_Y + CHEEK_Y_OFFSET, CHEEK_RADIUS, CLR_PINK);
}

void drawEyes() {
  int ly = CENTER_Y + EYE_Y_OFFSET;
  drawSingleEye(CENTER_X - EYE_SPACING, ly, currentFace.eyesClosed);
  drawSingleEye(CENTER_X + EYE_SPACING, ly, currentFace.eyesClosed);
}

void drawSingleEye(int x, int y, bool closed) {
  if (closed) {
    int hw = 30;
    for (int t = -3; t <= 3; t++) {
      for (int i = -hw; i <= hw; i++) {
        float n = (float)i / hw;
        int cy = (int)(n * n * 18);
        tft.drawPixel(x + i, y + cy + t, CLR_BLACK);
      }
    }
  } else {
    tft.fillCircle(x, y, EYE_RADIUS, CLR_WHITE);
    tft.drawCircle(x, y, EYE_RADIUS, CLR_GRAY);

    int py = y + currentFace.pupilOffset;
    tft.fillCircle(x, py, PUPIL_RADIUS, CLR_BLACK);
    tft.fillCircle(x - 6, py - 6, 6, CLR_WHITE);
    tft.fillCircle(x - 9, py - 9, 2, CLR_WHITE);
  }
}

void clearEyes() {
  int ey = CENTER_Y + EYE_Y_OFFSET;
  int r = EYE_RADIUS + 5;
  tft.fillRect(CENTER_X - EYE_SPACING - r, ey - r, r * 2, r * 2, CLR_BG);
  tft.fillRect(CENTER_X + EYE_SPACING - r, ey - r, r * 2, r * 2, CLR_BG);
  drawCheeks();
}

void clearMouth() {
  tft.fillRect(CENTER_X - MOUTH_WIDTH - 30, CENTER_Y + MOUTH_Y - 30,
               (MOUTH_WIDTH + 30) * 2, 80, CLR_BG);
}

void drawMouth() {
  int cx = CENTER_X;
  int cy = CENTER_Y + MOUTH_Y;
  int w  = MOUTH_WIDTH;
  int mc = currentFace.mouthCurve;

  if (mc > 0) {
    int curve = mc * -5;
    for (int t = -3; t <= 3; t++) {
      for (int i = -w; i <= w; i++) {
        float n = (float)i / w;
        int y = cy + (int)(n * n * curve) + t;
        tft.drawPixel(cx + i, y, CLR_BLACK);
      }
    }
    if (mc > 10) {
      int oy = cy + curve + 10;
      tft.fillCircle(cx, oy, 20, CLR_BLACK);
      tft.fillCircle(cx, oy + 6, 14, CLR_RED);
    }
  } else if (mc < 0) {
    int curve = abs(mc) * 4;
    for (int t = -3; t <= 3; t++) {
      for (int i = -w; i <= w; i++) {
        float n = (float)i / w;
        int y = cy - (int)(n * n * curve) + t;
        tft.drawPixel(cx + i, y, CLR_BLACK);
      }
    }
    if (mc < -8) {
      tft.fillCircle(cx, cy - curve - 5, 10, CLR_BLACK);
    }
  } else {
    for (int t = -2; t <= 2; t++) {
      tft.drawFastHLine(cx - w, cy + t, w * 2, CLR_BLACK);
    }
  }
}

void updateFaceAnimation() {
  if (millis() - lastFrameMs < 50) return;
  lastFrameMs = millis();

  FaceParams old = currentFace;

  currentFace.eyeOpen     += constrain(targetFace.eyeOpen - currentFace.eyeOpen, -2, 2);
  currentFace.pupilOffset += constrain(targetFace.pupilOffset - currentFace.pupilOffset, -1, 1);
  currentFace.mouthCurve  += constrain(targetFace.mouthCurve - currentFace.mouthCurve, -1, 1);
  currentFace.eyesClosed   = targetFace.eyesClosed;

  bool eyesChanged = (currentFace.eyeOpen != old.eyeOpen ||
                      currentFace.pupilOffset != old.pupilOffset ||
                      currentFace.eyesClosed != old.eyesClosed);
  bool mouthChanged = (currentFace.mouthCurve != old.mouthCurve);

  if (eyesChanged) { clearEyes(); drawEyes(); }
  if (mouthChanged) { clearMouth(); drawMouth(); }
}

void handleBlink() {
  if (currentFace.eyesClosed) return;
  if (millis() - lastBlinkMs > 3500) {
    lastBlinkMs = millis();

    clearEyes();
    int ey = CENTER_Y + EYE_Y_OFFSET;
    drawSingleEye(CENTER_X - EYE_SPACING, ey, true);
    drawSingleEye(CENTER_X + EYE_SPACING, ey, true);
    delay(100);
    clearEyes();
    drawEyes();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EMOTION â†’ FACE MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FaceParams emotionToFace(Emotion e) {
  switch (e) {
    case Emotion::NEUTRAL:    return {30, 0, 3, false};
    case Emotion::CALM:       return {28, 0, 5, false};
    case Emotion::HAPPY:      return {0, 0, 10, true};
    case Emotion::PROUD:      return {0, 0, 14, true};
    case Emotion::VERY_PROUD: return {0, 0, 16, true};
    case Emotion::SAD:        return {32, 5, -5, false};
    case Emotion::VERY_SAD:   return {34, 8, -10, false};
    case Emotion::REMINDER:   return {34, 6, -8, false};
    default:                  return {28, 0, 5, false};
  }
}

String emotionToString(Emotion e) {
  switch (e) {
    case Emotion::NEUTRAL:    return "Neutral";
    case Emotion::CALM:       return "Calm";
    case Emotion::HAPPY:      return "Happy";
    case Emotion::PROUD:      return "Proud";
    case Emotion::VERY_PROUD: return "Very Proud";
    case Emotion::SAD:        return "Sad";
    case Emotion::VERY_SAD:   return "Very Sad";
    case Emotion::REMINDER:   return "Reminder";
    default:                  return "Unknown";
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

uint32_t getEpoch() {
  if (hw_rtc) return rtc.now().unixtime();
  return millis() / 1000;
}

uint32_t getBookSeconds(uint8_t i) {
  uint32_t total = books[i].cumulativeSeconds;
  if (books[i].tracking && books[i].placedEpoch > 0) {
    uint32_t now = getEpoch();
    if (now > books[i].placedEpoch) {
      total += (now - books[i].placedEpoch);
    }
  }
  return total;
}

String formatSeconds(uint32_t s) {
  uint32_t h = s / 3600;
  uint32_t m = (s % 3600) / 60;
  uint32_t sec = s % 60;
  char buf[20];
  if (h > 0) sprintf(buf, "%dh %dm", h, m);
  else if (m > 0) sprintf(buf, "%dm %ds", m, sec);
  else sprintf(buf, "%ds", sec);
  return String(buf);
}

void playAudio(uint8_t track) {
  if (hw_dfplayer && settings.soundEnabled) {
    dfPlayer.playMp3Folder(track);
  }
}

void buzz(uint16_t onMs, uint16_t offMs, uint8_t repeats) {
  for (uint8_t i = 0; i < repeats; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(onMs);
    digitalWrite(BUZZER_PIN, LOW);
    if (offMs > 0 && i < repeats - 1) delay(offMs);
  }
}

void addHistory(const char* event, const char* detail) {
  HistoryEntry& e = history[historyHead];
  e.epoch = getEpoch();
  strncpy(e.event, event, sizeof(e.event) - 1);
  e.event[sizeof(e.event) - 1] = 0;
  strncpy(e.detail, detail, sizeof(e.detail) - 1);
  e.detail[sizeof(e.detail) - 1] = 0;

  historyHead = (historyHead + 1) % HISTORY_SIZE;
  if (historyCount < HISTORY_SIZE) historyCount++;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  JSON BUILDERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

String buildStatusJson() {
  StaticJsonDocument<1024> doc;

  doc["firmware"] = FIRMWARE_VER;
  doc["uptime"] = millis() / 1000;
  doc["freeHeap"] = ESP.getFreeHeap();
  doc["emotion"] = emotionToString(currentEmotion);
  doc["state"] = (int)sysState;
  doc["booksPlaced"] = bookCount;
  doc["degradeStage"] = degradeStage;

  if (hw_rtc) {
    DateTime now = rtc.now();
    char buf[25];
    sprintf(buf, "%04d-%02d-%02dT%02d:%02d:%02d",
            now.year(), now.month(), now.day(),
            now.hour(), now.minute(), now.second());
    doc["time"] = buf;
  } else {
    doc["time"] = "N/A";
  }

  JsonObject hw = doc.createNestedObject("hardware");
  hw["rtc"] = hw_rtc;
  hw["dfplayer"] = hw_dfplayer;
  hw["wifi"] = hw_wifi;

  JsonArray booksArr = doc.createNestedArray("books");
  uint32_t totalStudy = 0;
  for (int i = 0; i < 5; i++) {
    JsonObject b = booksArr.createNestedObject();
    b["name"] = books[i].name;
    b["present"] = books[i].present;
    b["seconds"] = getBookSeconds(i);
    totalStudy += getBookSeconds(i);
  }
  doc["totalStudySeconds"] = totalStudy;

  JsonObject timing = doc.createNestedObject("timing");
  timing["bootCalm"] = (sysState == SystemState::BOOT_CALM);
  timing["calmHold"] = (sysState == SystemState::CALM_HOLD);
  timing["degrading"] = (sysState == SystemState::DEGRADING);
  timing["stateElapsedMs"] = millis() - stateEnteredAt;

  JsonObject sett = doc.createNestedObject("settings");
  sett["volume"] = settings.volume;
  sett["soundEnabled"] = settings.soundEnabled;
  sett["bootCalmMs"] = settings.bootCalmMs;
  sett["calmHoldMs"] = settings.calmHoldMs;
  sett["degradeIntervalMs"] = settings.degradeIntervalMs;

  String output;
  serializeJson(doc, output);
  return output;
}

String buildHistoryJson() {
  StaticJsonDocument<4096> doc;
  JsonArray arr = doc.createNestedArray("history");

  int idx = (historyHead - historyCount + HISTORY_SIZE) % HISTORY_SIZE;
  for (int i = 0; i < historyCount; i++) {
    JsonObject entry = arr.createNestedObject();
    entry["epoch"] = history[idx].epoch;
    entry["event"] = history[idx].event;
    entry["detail"] = history[idx].detail;
    idx = (idx + 1) % HISTORY_SIZE;
  }

  String output;
  serializeJson(doc, output);
  return output;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEBSOCKET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initWebSocket() {
  ws.onEvent([](AsyncWebSocket* srv, AsyncWebSocketClient* client,
                AwsEventType type, void* arg, uint8_t* data, size_t len) {
    switch (type) {
      case WS_EVT_CONNECT:
        Serial.printf("WS[%u] connected\n", client->id());
        client->text(buildStatusJson());
        break;
      case WS_EVT_DISCONNECT:
        Serial.printf("WS[%u] disconnected\n", client->id());
        break;
      case WS_EVT_DATA: {
        AwsFrameInfo* info = (AwsFrameInfo*)arg;
        if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
          String msg = "";
          for (size_t i = 0; i < len; i++) msg += (char)data[i];

          StaticJsonDocument<256> cmdDoc;
          DeserializationError err = deserializeJson(cmdDoc, msg);
          if (!err) {
            handleWsCommand(client, cmdDoc);
          }
        }
        break;
      }
      default:
        break;
    }
  });
  server.addHandler(&ws);
  Serial.println("âœ“ WebSocket at /ws");
}

void handleWsCommand(AsyncWebSocketClient* client, StaticJsonDocument<256>& doc) {
  const char* cmd = doc["cmd"];
  if (!cmd) return;

  if (strcmp(cmd, "ping") == 0) {
    client->text("{\"cmd\":\"pong\"}");
  }
  else if (strcmp(cmd, "status") == 0) {
    client->text(buildStatusJson());
  }
  else if (strcmp(cmd, "history") == 0) {
    client->text(buildHistoryJson());
  }
  else if (strcmp(cmd, "setVolume") == 0) {
    int vol = doc["value"] | 22;
    settings.volume = constrain(vol, 0, 30);
    if (hw_dfplayer) dfPlayer.volume(settings.volume);
    saveSettings();
    client->text("{\"cmd\":\"ok\",\"action\":\"volume\",\"value\":" + String(settings.volume) + "}");
  }
  else if (strcmp(cmd, "setSound") == 0) {
    settings.soundEnabled = doc["value"] | true;
    saveSettings();
    client->text("{\"cmd\":\"ok\",\"action\":\"sound\"}");
  }
  else if (strcmp(cmd, "resetTimers") == 0) {
    for (int i = 0; i < 5; i++) {
      books[i].cumulativeSeconds = 0;
      books[i].sessionSeconds = 0;
    }
    addHistory("RESET", "Timers cleared");
    client->text("{\"cmd\":\"ok\",\"action\":\"resetTimers\"}");
  }
  else if (strcmp(cmd, "syncTime") == 0) {
    uint32_t epoch = doc["epoch"] | 0;
    if (hw_rtc && epoch > 1000000000) {
      rtc.adjust(DateTime(epoch));
      addHistory("SYNC", "Time synced");
      client->text("{\"cmd\":\"ok\",\"action\":\"syncTime\"}");
    } else {
      client->text("{\"cmd\":\"error\",\"msg\":\"Invalid epoch or no RTC\"}");
    }
  }
  else if (strcmp(cmd, "playAudio") == 0) {
    int track = doc["track"] | 0;
    if (track > 0) playAudio(track);
    client->text("{\"cmd\":\"ok\",\"action\":\"playAudio\"}");
  }
  else if (strcmp(cmd, "buzz") == 0) {
    buzz(200, 100, 2);
    client->text("{\"cmd\":\"ok\",\"action\":\"buzz\"}");
  }
  else if (strcmp(cmd, "updateSettings") == 0) {
    if (doc.containsKey("bootCalmMs")) settings.bootCalmMs = doc["bootCalmMs"];
    if (doc.containsKey("calmHoldMs")) settings.calmHoldMs = doc["calmHoldMs"];
    if (doc.containsKey("degradeIntervalMs")) settings.degradeIntervalMs = doc["degradeIntervalMs"];
    saveSettings();
    client->text("{\"cmd\":\"ok\",\"action\":\"updateSettings\"}");
  }
}

void updateWebSocket() {
  if (!hw_wifi || ws.count() == 0) return;
  if (millis() - lastWsBroadcast < 2000) return;
  lastWsBroadcast = millis();
  ws.textAll(buildStatusJson());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEB SERVER - EMBEDDED DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initWebServer() {
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Headers", "Content-Type");

  // â”€â”€ Main Dashboard Page â”€â”€
  server.on("/", HTTP_GET, serveMainPage);

  // â”€â”€ REST API â”€â”€
  server.on("/api/status", HTTP_GET, [](AsyncWebServerRequest* req) {
    req->send(200, "application/json", buildStatusJson());
  });

  server.on("/api/history", HTTP_GET, [](AsyncWebServerRequest* req) {
    req->send(200, "application/json", buildHistoryJson());
  });

  server.on("/api/settings", HTTP_GET, [](AsyncWebServerRequest* req) {
    StaticJsonDocument<256> doc;
    doc["volume"] = settings.volume;
    doc["soundEnabled"] = settings.soundEnabled;
    doc["bootCalmMs"] = settings.bootCalmMs;
    doc["calmHoldMs"] = settings.calmHoldMs;
    doc["degradeIntervalMs"] = settings.degradeIntervalMs;
    String output;
    serializeJson(doc, output);
    req->send(200, "application/json", output);
  });

  server.on("/api/synctime", HTTP_POST, [](AsyncWebServerRequest* req) {}, NULL,
    [](AsyncWebServerRequest* req, uint8_t* data, size_t len, size_t index, size_t total) {
      StaticJsonDocument<128> doc;
      String body = "";
      for (size_t i = 0; i < len; i++) body += (char)data[i];

      if (deserializeJson(doc, body) == DeserializationError::Ok) {
        uint32_t epoch = doc["epoch"] | 0;
        if (hw_rtc && epoch > 1000000000) {
          rtc.adjust(DateTime(epoch));
          addHistory("SYNC", "Time synced via API");
          req->send(200, "application/json", "{\"success\":true}");
          return;
        }
      }
      req->send(400, "application/json", "{\"error\":\"Invalid request\"}");
    }
  );

  server.on("/api/reset", HTTP_POST, [](AsyncWebServerRequest* req) {
    for (int i = 0; i < 5; i++) {
      books[i].cumulativeSeconds = 0;
      books[i].sessionSeconds = 0;
    }
    addHistory("RESET", "Via API");
    req->send(200, "application/json", "{\"success\":true}");
  });

  server.on("/api/info", HTTP_GET, [](AsyncWebServerRequest* req) {
    StaticJsonDocument<256> doc;
    doc["device"] = DEVICE_NAME;
    doc["firmware"] = FIRMWARE_VER;
    doc["chip"] = ESP.getChipModel();
    doc["cpuFreq"] = ESP.getCpuFreqMHz();
    doc["freeHeap"] = ESP.getFreeHeap();
    doc["totalHeap"] = ESP.getHeapSize();
    doc["uptime"] = millis() / 1000;
    doc["ip"] = WiFi.localIP().toString();
    doc["rssi"] = WiFi.RSSI();
    doc["mac"] = WiFi.macAddress();

    String output;
    serializeJson(doc, output);
    req->send(200, "application/json", output);
  });

  // â”€â”€ OTA Update â”€â”€
  server.on("/update", HTTP_POST,
    [](AsyncWebServerRequest* req) {
      bool ok = !Update.hasError();
      req->send(200, "application/json",
                ok ? "{\"success\":true,\"msg\":\"Rebooting...\"}"
                   : "{\"success\":false,\"msg\":\"Update failed\"}");
      if (ok) delay(1000);
      if (ok) ESP.restart();
    },
    [](AsyncWebServerRequest* req, const String& filename, size_t index,
       uint8_t* data, size_t len, bool final) {
      if (!index) {
        Serial.printf("OTA Start: %s\n", filename.c_str());
        Update.begin(UPDATE_SIZE_UNKNOWN);
      }
      Update.write(data, len);
      if (final) {
        Update.end(true);
        Serial.println("OTA Complete");
      }
    }
  );

  server.begin();
  Serial.printf("âœ“ Web server at http://%s/\n", WiFi.localIP().toString().c_str());
  Serial.printf("  Also: http://%s.local/\n", MDNS_NAME);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EMBEDDED DASHBOARD HTML
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void serveMainPage(AsyncWebServerRequest* req) {
  // This is the complete single-page dashboard
  // Using raw string literals for the HTML

  String html = R"rawhtml(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BookBuddy Dashboard</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0f172a;--card:#1e293b;--card2:#334155;
  --accent:#3b82f6;--accent2:#60a5fa;
  --green:#22c55e;--red:#ef4444;--amber:#f59e0b;--purple:#a855f7;
  --text:#f1f5f9;--text2:#94a3b8;--border:#475569;
  --radius:16px;
}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;overflow-x:hidden}
.container{max-width:1200px;margin:0 auto;padding:16px}

/* Header */
.header{text-align:center;padding:24px 0 16px;position:relative}
.header h1{font-size:2.2em;font-weight:800;background:linear-gradient(135deg,var(--accent2),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent;display:inline}
.header .subtitle{color:var(--text2);font-size:.95em;margin-top:4px}
.conn-badge{display:inline-flex;align-items:center;gap:6px;padding:6px 16px;border-radius:20px;font-size:.85em;font-weight:600;margin-top:8px}
.conn-badge.online{background:#22c55e22;color:var(--green);border:1px solid #22c55e44}
.conn-badge.offline{background:#ef444422;color:var(--red);border:1px solid #ef444444}
.conn-dot{width:8px;height:8px;border-radius:50%;background:currentColor;animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}

/* Grid */
.grid{display:grid;gap:16px;margin-top:16px}
.grid-2{grid-template-columns:1fr 1fr}
.grid-3{grid-template-columns:1fr 1fr 1fr}
.grid-5{grid-template-columns:repeat(5,1fr)}
@media(max-width:900px){.grid-3,.grid-5{grid-template-columns:1fr 1fr}.grid-2{grid-template-columns:1fr}}
@media(max-width:600px){.grid-2,.grid-3,.grid-5{grid-template-columns:1fr}}

/* Cards */
.card{background:var(--card);border-radius:var(--radius);padding:20px;border:1px solid var(--border);transition:transform .2s,box-shadow .2s}
.card:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(0,0,0,.3)}
.card h3{font-size:.85em;color:var(--text2);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px}
.card .value{font-size:2em;font-weight:700}
.card .detail{font-size:.8em;color:var(--text2);margin-top:4px}

/* Emotion Card */
.emotion-card{text-align:center;padding:30px;position:relative;overflow:hidden}
.emotion-face{font-size:4em;margin-bottom:8px}
.emotion-name{font-size:1.5em;font-weight:700}
.emotion-bar{height:4px;border-radius:2px;margin-top:12px;background:var(--card2)}
.emotion-bar-fill{height:100%;border-radius:2px;transition:width .5s}

/* Book Cards */
.book-card{position:relative;overflow:hidden}
.book-card .status-dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:8px;transition:background .3s}
.book-card .status-dot.on{background:var(--green);box-shadow:0 0 8px var(--green)}
.book-card .status-dot.off{background:var(--border)}
.book-card .book-name{font-size:1.1em;font-weight:600}
.book-card .book-time{font-size:1.5em;font-weight:700;margin-top:8px;font-variant-numeric:tabular-nums}
.book-card .book-status{font-size:.8em;color:var(--text2);margin-top:4px}
.book-card.active{border-color:var(--green)}
.book-card.active::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:var(--green)}

/* Progress Bar */
.progress-section{padding:24px}
.progress-bar{height:24px;background:var(--card2);border-radius:12px;overflow:hidden;position:relative}
.progress-fill{height:100%;border-radius:12px;background:linear-gradient(90deg,var(--accent),var(--green));transition:width .5s;position:relative}
.progress-text{position:absolute;right:12px;top:50%;transform:translateY(-50%);font-size:.8em;font-weight:600}
.progress-label{display:flex;justify-content:space-between;margin-top:8px;font-size:.85em;color:var(--text2)}

/* History */
.history-list{max-height:400px;overflow-y:auto;padding-right:8px}
.history-list::-webkit-scrollbar{width:6px}
.history-list::-webkit-scrollbar-track{background:var(--card2);border-radius:3px}
.history-list::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
.history-item{display:flex;align-items:center;gap:12px;padding:10px;border-radius:8px;margin-bottom:4px;background:var(--card2);font-size:.9em}
.history-item .h-icon{font-size:1.2em;min-width:28px;text-align:center}
.history-item .h-time{color:var(--text2);font-size:.8em;min-width:60px}
.history-item .h-event{font-weight:600}
.history-item .h-detail{color:var(--text2);margin-left:auto}

/* Controls */
.controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:600px){.controls-grid{grid-template-columns:1fr}}
.btn{padding:12px 20px;border:none;border-radius:12px;font-size:.95em;font-weight:600;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:8px;color:var(--text)}
.btn:hover{transform:translateY(-1px)}
.btn:active{transform:scale(.97)}
.btn-primary{background:var(--accent)}
.btn-primary:hover{background:#2563eb}
.btn-green{background:var(--green)}
.btn-green:hover{background:#16a34a}
.btn-amber{background:var(--amber);color:#000}
.btn-amber:hover{background:#d97706}
.btn-red{background:var(--red)}
.btn-red:hover{background:#dc2626}
.btn-purple{background:var(--purple)}
.btn-purple:hover{background:#9333ea}
.btn-ghost{background:var(--card2);border:1px solid var(--border)}
.btn-ghost:hover{background:var(--border)}

/* Settings */
.setting-row{display:flex;align-items:center;justify-content:space-between;padding:14px 0;border-bottom:1px solid var(--card2)}
.setting-row:last-child{border-bottom:none}
.setting-label{font-weight:500}
.setting-label small{display:block;color:var(--text2);font-weight:400;font-size:.8em;margin-top:2px}
.slider-wrap{display:flex;align-items:center;gap:12px}
input[type=range]{-webkit-appearance:none;width:150px;height:6px;border-radius:3px;background:var(--card2);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:20px;height:20px;border-radius:50%;background:var(--accent);cursor:pointer}
.toggle{position:relative;width:48px;height:26px;cursor:pointer}
.toggle input{opacity:0;width:0;height:0}
.toggle .slider{position:absolute;inset:0;background:var(--card2);border-radius:13px;transition:.3s}
.toggle .slider::before{content:'';position:absolute;width:20px;height:20px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:.3s}
.toggle input:checked+.slider{background:var(--green)}
.toggle input:checked+.slider::before{transform:translateX(22px)}

/* HW Status */
.hw-row{display:flex;align-items:center;gap:10px;padding:8px 0}
.hw-dot{width:10px;height:10px;border-radius:50%}
.hw-dot.ok{background:var(--green)}
.hw-dot.fail{background:var(--red)}

/* Tabs */
.tabs{display:flex;gap:4px;margin-bottom:16px;background:var(--card);border-radius:12px;padding:4px;border:1px solid var(--border)}
.tab{flex:1;padding:10px;text-align:center;border-radius:8px;cursor:pointer;font-weight:600;font-size:.9em;transition:all .2s;color:var(--text2)}
.tab.active{background:var(--accent);color:#fff}
.tab:hover:not(.active){background:var(--card2)}

/* Toast */
.toast{position:fixed;bottom:24px;right:24px;padding:14px 24px;border-radius:12px;font-weight:600;font-size:.9em;transform:translateY(100px);opacity:0;transition:all .3s;z-index:1000}
.toast.show{transform:translateY(0);opacity:1}
.toast.success{background:var(--green);color:#fff}
.toast.error{background:var(--red);color:#fff}
.toast.info{background:var(--accent);color:#fff}

/* Footer */
.footer{text-align:center;padding:20px;color:var(--text2);font-size:.8em;margin-top:24px}

/* Fade in animation */
.fade-in{animation:fadeIn .5s ease}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
</style>
</head>
<body>

<div class="container">
  <!-- Header -->
  <div class="header fade-in">
    <h1>ğŸ“š BookBuddy</h1>
    <div class="subtitle">Smart Study Companion Dashboard</div>
    <div id="connBadge" class="conn-badge offline">
      <span class="conn-dot"></span>
      <span id="connText">Connecting...</span>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tabs fade-in" style="animation-delay:.1s">
    <div class="tab active" onclick="switchTab('dashboard')">ğŸ“Š Dashboard</div>
    <div class="tab" onclick="switchTab('history')">ğŸ“œ History</div>
    <div class="tab" onclick="switchTab('controls')">ğŸ® Controls</div>
    <div class="tab" onclick="switchTab('settings')">âš™ï¸ Settings</div>
  </div>

  <!-- â•â•â•â•â•â• DASHBOARD TAB â•â•â•â•â•â• -->
  <div id="tab-dashboard">
    <!-- Top Stats -->
    <div class="grid grid-3 fade-in" style="animation-delay:.2s">
      <div class="card emotion-card" id="emotionCard">
        <div class="emotion-face" id="emotionFace">ğŸ˜Š</div>
        <div class="emotion-name" id="emotionName">Connecting...</div>
        <div class="detail" id="stateDetail">--</div>
      </div>
      <div class="card" style="text-align:center">
        <h3>Books Placed</h3>
        <div class="value" id="bookCountDisplay">-</div>
        <div class="detail">of 5 subjects</div>
        <div class="progress-bar" style="margin-top:12px;height:8px">
          <div class="progress-fill" id="bookProgress" style="width:0%"></div>
        </div>
      </div>
      <div class="card" style="text-align:center">
        <h3>Total Study Time</h3>
        <div class="value" id="totalStudy">--</div>
        <div class="detail" id="clockDisplay">--:--:--</div>
      </div>
    </div>

    <!-- Book Cards -->
    <div class="grid grid-5 fade-in" style="animation-delay:.3s;margin-top:16px">
      <div class="card book-card" id="book-0">
        <span class="status-dot off" id="dot-0"></span>
        <span class="book-name">English</span>
        <div class="book-time" id="time-0">0s</div>
        <div class="book-status" id="status-0">Not placed</div>
      </div>
      <div class="card book-card" id="book-1">
        <span class="status-dot off" id="dot-1"></span>
        <span class="book-name">Hindi</span>
        <div class="book-time" id="time-1">0s</div>
        <div class="book-status" id="status-1">Not placed</div>
      </div>
      <div class="card book-card" id="book-2">
        <span class="status-dot off" id="dot-2"></span>
        <span class="book-name">Maths</span>
        <div class="book-time" id="time-2">0s</div>
        <div class="book-status" id="status-2">Not placed</div>
      </div>
      <div class="card book-card" id="book-3">
        <span class="status-dot off" id="dot-3"></span>
        <span class="book-name">Marathi</span>
        <div class="book-time" id="time-3">0s</div>
        <div class="book-status" id="status-3">Not placed</div>
      </div>
      <div class="card book-card" id="book-4">
        <span class="status-dot off" id="dot-4"></span>
        <span class="book-name">Science</span>
        <div class="book-time" id="time-4">0s</div>
        <div class="book-status" id="status-4">Not placed</div>
      </div>
    </div>

    <!-- System Info -->
    <div class="grid grid-2 fade-in" style="animation-delay:.4s;margin-top:16px">
      <div class="card">
        <h3>System Info</h3>
        <div class="hw-row"><span class="hw-dot" id="hw-rtc"></span> RTC Clock</div>
        <div class="hw-row"><span class="hw-dot" id="hw-dfplayer"></span> DFPlayer Audio</div>
        <div class="hw-row"><span class="hw-dot" id="hw-wifi"></span> WiFi Connection</div>
        <div style="margin-top:12px;font-size:.85em;color:var(--text2)">
          <div>Firmware: <span id="fwVersion">--</span></div>
          <div>Uptime: <span id="uptime">--</span></div>
          <div>Free Heap: <span id="freeHeap">--</span></div>
          <div>WiFi RSSI: <span id="rssi">--</span></div>
        </div>
      </div>
      <div class="card">
        <h3>Study Progress</h3>
        <div id="progressBars"></div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â• HISTORY TAB â•â•â•â•â•â• -->
  <div id="tab-history" style="display:none">
    <div class="card fade-in">
      <h3>Event History</h3>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <span id="historyCount" style="color:var(--text2);font-size:.9em">Loading...</span>
        <button class="btn btn-ghost" onclick="requestHistory()" style="padding:8px 16px;font-size:.85em">ğŸ”„ Refresh</button>
      </div>
      <div class="history-list" id="historyList">
        <div style="text-align:center;padding:40px;color:var(--text2)">Waiting for data...</div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â• CONTROLS TAB â•â•â•â•â•â• -->
  <div id="tab-controls" style="display:none">
    <div class="card fade-in">
      <h3>Remote Controls</h3>
      <div class="controls-grid" style="margin-top:16px">
        <button class="btn btn-primary" onclick="sendCmd('status')">ğŸ“Š Get Status</button>
        <button class="btn btn-green" onclick="syncTime()">ğŸ• Sync Time</button>
        <button class="btn btn-amber" onclick="sendCmd('buzz')">ğŸ”” Buzz</button>
        <button class="btn btn-purple" onclick="sendCmd('playAudio',{track:34})">ğŸµ Play Chime</button>
        <button class="btn btn-red" onclick="confirmReset()">ğŸ—‘ï¸ Reset Timers</button>
        <button class="btn btn-ghost" onclick="requestHistory()">ğŸ“œ Get History</button>
      </div>
    </div>

    <div class="card fade-in" style="margin-top:16px">
      <h3>Audio Test</h3>
      <div class="controls-grid" style="margin-top:12px">
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:1})">Hey!</button>
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:3})">BookBuddy</button>
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:5})">Time to Study</button>
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:31})">Good Job</button>
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:32})">Well Done</button>
        <button class="btn btn-ghost" onclick="sendCmd('playAudio',{track:33})">Uh Oh</button>
      </div>
    </div>

    <div class="card fade-in" style="margin-top:16px">
      <h3>OTA Firmware Update</h3>
      <form id="otaForm" style="margin-top:12px">
        <input type="file" id="otaFile" accept=".bin" style="margin-bottom:12px;color:var(--text)">
        <button type="submit" class="btn btn-amber" style="width:100%">ğŸ“¦ Upload Firmware</button>
      </form>
      <div id="otaProgress" style="display:none;margin-top:12px">
        <div class="progress-bar"><div class="progress-fill" id="otaBar" style="width:0%"></div></div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â• SETTINGS TAB â•â•â•â•â•â• -->
  <div id="tab-settings" style="display:none">
    <div class="card fade-in">
      <h3>Device Settings</h3>

      <div class="setting-row">
        <div class="setting-label">Volume<small>Speaker volume (0-30)</small></div>
        <div class="slider-wrap">
          <span id="volVal">22</span>
          <input type="range" min="0" max="30" value="22" id="volumeSlider" oninput="updateVolume(this.value)">
        </div>
      </div>

      <div class="setting-row">
        <div class="setting-label">Sound<small>Enable/disable audio</small></div>
        <label class="toggle">
          <input type="checkbox" checked id="soundToggle" onchange="toggleSound(this.checked)">
          <span class="slider"></span>
        </label>
      </div>

      <div class="setting-row">
        <div class="setting-label">Boot Calm (min)<small>Calm period after startup</small></div>
        <div class="slider-wrap">
          <span id="bcVal">5</span>
          <input type="range" min="1" max="30" value="5" id="bootCalmSlider" oninput="document.getElementById('bcVal').textContent=this.value">
        </div>
      </div>

      <div class="setting-row">
        <div class="setting-label">Calm Hold (min)<small>Calm after all books placed</small></div>
        <div class="slider-wrap">
          <span id="chVal">5</span>
          <input type="range" min="1" max="30" value="5" id="calmHoldSlider" oninput="document.getElementById('chVal').textContent=this.value">
        </div>
      </div>

      <div class="setting-row">
        <div class="setting-label">Degrade Interval (min)<small>Time per emotion stage</small></div>
        <div class="slider-wrap">
          <span id="diVal">5</span>
          <input type="range" min="1" max="30" value="5" id="degradeSlider" oninput="document.getElementById('diVal').textContent=this.value">
        </div>
      </div>

      <button class="btn btn-primary" onclick="saveSettingsToDevice()" style="width:100%;margin-top:16px">ğŸ’¾ Save Settings</button>
    </div>
  </div>

  <div class="footer">
    BookBuddy V1 &bull; <span id="ipDisplay">--</span> &bull; <span id="wsStatus">Disconnected</span>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WebSocket Connection Manager
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ws = null;
let wsConnected = false;
let reconnectTimer = null;
let lastData = null;
let pingInterval = null;

function connect() {
  const host = location.hostname || 'bookbuddy.local';
  const url = 'ws://' + host + '/ws';
  console.log('Connecting to', url);

  try {
    ws = new WebSocket(url);
  } catch(e) {
    console.error('WS error:', e);
    scheduleReconnect();
    return;
  }

  ws.onopen = function() {
    console.log('WS connected');
    wsConnected = true;
    updateConnectionUI(true);
    clearTimeout(reconnectTimer);

    // Heartbeat
    clearInterval(pingInterval);
    pingInterval = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({cmd:'ping'}));
      }
    }, 15000);
  };

  ws.onmessage = function(evt) {
    try {
      const data = JSON.parse(evt.data);
      if (data.cmd === 'pong') return;
      if (data.history) {
        renderHistory(data.history);
        return;
      }
      if (data.cmd === 'ok' || data.cmd === 'error') {
        showToast(data.cmd === 'ok' ? 'Command OK: ' + (data.action||'') : 'Error: ' + (data.msg||''),
                  data.cmd === 'ok' ? 'success' : 'error');
        return;
      }
      lastData = data;
      updateDashboard(data);
    } catch(e) {
      console.error('Parse error:', e);
    }
  };

  ws.onclose = function() {
    console.log('WS closed');
    wsConnected = false;
    updateConnectionUI(false);
    clearInterval(pingInterval);
    scheduleReconnect();
  };

  ws.onerror = function(e) {
    console.error('WS error:', e);
    ws.close();
  };
}

function scheduleReconnect() {
  clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(connect, 3000);
}

function sendCmd(cmd, extra) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    showToast('Not connected', 'error');
    return;
  }
  const msg = {cmd, ...extra};
  ws.send(JSON.stringify(msg));
}

function requestHistory() {
  sendCmd('history');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI Updates
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateConnectionUI(connected) {
  const badge = document.getElementById('connBadge');
  const text = document.getElementById('connText');
  const footer = document.getElementById('wsStatus');

  if (connected) {
    badge.className = 'conn-badge online';
    text.textContent = 'Connected';
    footer.textContent = 'WebSocket: Connected';
  } else {
    badge.className = 'conn-badge offline';
    text.textContent = 'Reconnecting...';
    footer.textContent = 'WebSocket: Disconnected';
  }
}

const EMOTION_MAP = {
  'Neutral':    {face:'ğŸ˜', color:'var(--text2)'},
  'Calm':       {face:'ğŸ˜Š', color:'var(--accent2)'},
  'Happy':      {face:'ğŸ˜„', color:'var(--green)'},
  'Proud':      {face:'ğŸ¤©', color:'var(--amber)'},
  'Very Proud': {face:'ğŸ¥³', color:'var(--amber)'},
  'Sad':        {face:'ğŸ˜Ÿ', color:'var(--amber)'},
  'Very Sad':   {face:'ğŸ˜¢', color:'var(--red)'},
  'Reminder':   {face:'ğŸ˜¤', color:'var(--red)'}
};

const STATE_NAMES = ['Booting','Intro','Boot Calm','Active','Calm Hold','Degrading','Overlay'];

function updateDashboard(d) {
  // Emotion
  const emo = EMOTION_MAP[d.emotion] || {face:'â“', color:'var(--text2)'};
  document.getElementById('emotionFace').textContent = emo.face;
  document.getElementById('emotionName').textContent = d.emotion || '--';
  document.getElementById('emotionName').style.color = emo.color;
  document.getElementById('stateDetail').textContent = STATE_NAMES[d.state] || 'Unknown';

  // Books count
  document.getElementById('bookCountDisplay').textContent = d.booksPlaced + ' / 5';
  document.getElementById('bookProgress').style.width = (d.booksPlaced / 5 * 100) + '%';

  // Total study
  document.getElementById('totalStudy').textContent = formatTime(d.totalStudySeconds || 0);

  // Clock
  if (d.time && d.time !== 'N/A') {
    const t = d.time.split('T')[1] || d.time;
    document.getElementById('clockDisplay').textContent = 'ğŸ• ' + t;
  }

  // Books
  if (d.books) {
    let progressHTML = '';
    const maxSec = Math.max(...d.books.map(b => b.seconds), 1);

    d.books.forEach((b, i) => {
      const card = document.getElementById('book-' + i);
      const dot = document.getElementById('dot-' + i);
      const time = document.getElementById('time-' + i);
      const status = document.getElementById('status-' + i);

      if (card) {
        card.className = 'card book-card' + (b.present ? ' active' : '');
      }
      if (dot) {
        dot.className = 'status-dot ' + (b.present ? 'on' : 'off');
      }
      if (time) {
        time.textContent = formatTime(b.seconds);
      }
      if (status) {
        status.textContent = b.present ? 'ğŸ“— Studying' : 'ğŸ“• Not placed';
      }

      // Progress bars
      const pct = maxSec > 0 ? (b.seconds / maxSec * 100) : 0;
      const colors = ['var(--accent)','var(--green)','var(--amber)','var(--purple)','var(--red)'];
      progressHTML += '<div style="margin-bottom:8px">';
      progressHTML += '<div style="display:flex;justify-content:space-between;font-size:.85em;margin-bottom:2px">';
      progressHTML += '<span>' + b.name + '</span><span>' + formatTime(b.seconds) + '</span></div>';
      progressHTML += '<div class="progress-bar" style="height:8px"><div class="progress-fill" style="width:' + pct + '%;background:' + colors[i] + '"></div></div>';
      progressHTML += '</div>';
    });

    document.getElementById('progressBars').innerHTML = progressHTML;
  }

  // Hardware
  if (d.hardware) {
    setHwDot('hw-rtc', d.hardware.rtc);
    setHwDot('hw-dfplayer', d.hardware.dfplayer);
    setHwDot('hw-wifi', d.hardware.wifi);
  }

  // System info
  if (d.firmware) document.getElementById('fwVersion').textContent = d.firmware;
  if (d.uptime != null) document.getElementById('uptime').textContent = formatTime(d.uptime);
  if (d.freeHeap != null) document.getElementById('freeHeap').textContent = (d.freeHeap / 1024).toFixed(1) + ' KB';

  // Settings sync
  if (d.settings) {
    document.getElementById('volumeSlider').value = d.settings.volume;
    document.getElementById('volVal').textContent = d.settings.volume;
    document.getElementById('soundToggle').checked = d.settings.soundEnabled;
    document.getElementById('bootCalmSlider').value = d.settings.bootCalmMs / 60000;
    document.getElementById('bcVal').textContent = d.settings.bootCalmMs / 60000;
    document.getElementById('calmHoldSlider').value = d.settings.calmHoldMs / 60000;
    document.getElementById('chVal').textContent = d.settings.calmHoldMs / 60000;
    document.getElementById('degradeSlider').value = d.settings.degradeIntervalMs / 60000;
    document.getElementById('diVal').textContent = d.settings.degradeIntervalMs / 60000;
  }

  // IP
  document.getElementById('ipDisplay').textContent = location.hostname;
}

function setHwDot(id, ok) {
  const el = document.getElementById(id);
  if (el) el.className = 'hw-dot ' + (ok ? 'ok' : 'fail');
}

function renderHistory(items) {
  const list = document.getElementById('historyList');
  const count = document.getElementById('historyCount');
  count.textContent = items.length + ' events';

  if (!items.length) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text2)">No events yet</div>';
    return;
  }

  const icons = {
    'BOOT':'ğŸš€','PLACED':'ğŸ“—','REMOVED':'ğŸ“•','ALL_PLACED':'â­',
    'TOUCH':'ğŸ‘†','REMINDER':'â°','RESET':'ğŸ—‘ï¸','SYNC':'ğŸ•'
  };

  let html = '';
  items.reverse().forEach(e => {
    const icon = icons[e.event] || 'ğŸ“‹';
    const d = new Date(e.epoch * 1000);
    const timeStr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0');
    html += '<div class="history-item">';
    html += '<span class="h-icon">' + icon + '</span>';
    html += '<span class="h-time">' + timeStr + '</span>';
    html += '<span class="h-event">' + e.event + '</span>';
    html += '<span class="h-detail">' + (e.detail||'') + '</span>';
    html += '</div>';
  });

  list.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Actions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function syncTime() {
  const epoch = Math.floor(Date.now() / 1000);
  sendCmd('syncTime', {epoch});
  showToast('Time sync sent', 'info');
}

function confirmReset() {
  if (confirm('Reset all study timers to zero?')) {
    sendCmd('resetTimers');
  }
}

function updateVolume(val) {
  document.getElementById('volVal').textContent = val;
  sendCmd('setVolume', {value: parseInt(val)});
}

function toggleSound(enabled) {
  sendCmd('setSound', {value: enabled});
}

function saveSettingsToDevice() {
  const bc = parseInt(document.getElementById('bootCalmSlider').value) * 60000;
  const ch = parseInt(document.getElementById('calmHoldSlider').value) * 60000;
  const di = parseInt(document.getElementById('degradeSlider').value) * 60000;
  sendCmd('updateSettings', {bootCalmMs:bc, calmHoldMs:ch, degradeIntervalMs:di});
  showToast('Settings saved!', 'success');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Tabs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function switchTab(name) {
  ['dashboard','history','controls','settings'].forEach(t => {
    document.getElementById('tab-'+t).style.display = t === name ? '' : 'none';
  });
  document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
  event.target.classList.add('active');

  if (name === 'history') requestHistory();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  OTA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('otaForm').addEventListener('submit', function(e) {
  e.preventDefault();
  const file = document.getElementById('otaFile').files[0];
  if (!file) { showToast('Select a .bin file', 'error'); return; }

  const xhr = new XMLHttpRequest();
  const form = new FormData();
  form.append('update', file);

  document.getElementById('otaProgress').style.display = 'block';

  xhr.upload.onprogress = function(ev) {
    if (ev.lengthComputable) {
      const pct = (ev.loaded / ev.total * 100).toFixed(0);
      document.getElementById('otaBar').style.width = pct + '%';
    }
  };

  xhr.onload = function() {
    if (xhr.status === 200) {
      showToast('Update complete! Rebooting...', 'success');
      setTimeout(() => location.reload(), 5000);
    } else {
      showToast('Update failed', 'error');
    }
  };

  xhr.open('POST', '/update');
  xhr.send(form);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function formatTime(secs) {
  if (secs == null || secs < 0) return '--';
  const h = Math.floor(secs / 3600);
  const m = Math.floor((secs % 3600) / 60);
  const s = secs % 60;
  if (h > 0) return h + 'h ' + m + 'm';
  if (m > 0) return m + 'm ' + s + 's';
  return s + 's';
}

function showToast(msg, type) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast ' + type + ' show';
  setTimeout(() => t.className = 'toast', 3000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RSSI polling (via REST)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
setInterval(() => {
  fetch('/api/info').then(r=>r.json()).then(d => {
    if (d.rssi != null) document.getElementById('rssi').textContent = d.rssi + ' dBm';
  }).catch(()=>{});
}, 10000);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Init
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
connect();
</script>
</body>
</html>
)rawhtml";

  req->send(200, "text/html", html);
}
